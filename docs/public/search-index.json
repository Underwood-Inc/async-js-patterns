[
  {
    "title": "README",
    "path": "/.vitepress/theme/components/README",
    "content": "CodePreview Component Documentation\n\nOverview\n\nThe CodePreview system consists of two main parts:\n\n1. `CodePreview.vue` - A Vue component that renders an interactive Monaco editor\n2. `codePreview.ts` - A markdown plugin that transforms code blocks into CodePreview components\n\nUsage\n\nIn Markdown Files\n\nTo use the interactive code preview, add the `::: code-with-tooltips` wrapper to your code block:\n\ntypescript\n// Your code here\n.\n\njavascript\n// Your JavaScript code here\n.\n\nComponent Features\n\nThe CodePreview component supports:\n\n- Syntax highlighting\n- Type information and hover tooltips\n- IntelliSense suggestions\n- Multiple file views (optional)\n\nConfiguration\n\nBasic Usage\n\nvue\n<CodePreview\n  :code=\"yourCode\"\n  language=\"typescript\"\n/>\n.\n\nWith Multiple Files\n\nvue\n<CodePreview\n  :code=\"mainCode\"\n  :files=\"[\n    { name: 'main.ts', content: mainCode, language: 'typescript' },\n    { name: 'utils.ts', content: utilsCode, language: 'typescript' },\n  ]\"\n  :showFileTree=\"true\"\n/>\n.\n\nImplementa"
  },
  {
    "title": "CONTRIBUTING",
    "path": "/CONTRIBUTING",
    "content": "Contributing to Async JavaScript Patterns\n\nWe love your input! We want to make contributing to this project as easy and\ntransparent as possible, whether it's:\n\n- Reporting a bug\n- Discussing the current state of the code\n- Submitting a fix\n- Proposing new features\n- Becoming a maintainer\n\nDevelopment Process\n\nWe use GitHub to host code, to track issues and feature requests, as well as\naccept pull requests.\n\n1. Fork the repo and create your branch from `main`.\n2. If you've added code that should be tested, add tests.\n3. If you've changed APIs, update the documentation.\n4. Ensure the test suite passes.\n5. Make sure your code lints.\n6. Issue that pull request!\n\nPull Request Process\n\n1. Update the README.md with details of changes to the interface, if applicable.\n2. Update the docs with any new patterns or modifications to existing ones.\n3. The PR will be merged once you have the sign-off of at least one maintainer.\n\nAny Contributions You Make Will Be Under the CC BY 4.0 License\n\nIn short,"
  },
  {
    "title": "LICENSE",
    "path": "/LICENSE",
    "content": "Open RAIL-S v1.0\n\n1. Purpose. This license enables the development and sharing of AI systems and content in a responsible manner.\n\n2. Acceptance. By using, reproducing, or distributing this Work, you accept and agree to comply with the terms of this license.\n\n3. Definitions.\n\n   - \"Work\" refers to the software, content, and associated documentation in this repository\n   - \"Derivative Works\" means works based upon or derived from this Work\n   - \"You\" means the individual or entity exercising the rights under this License\n\n4. Grant of Rights. Subject to the terms of this License, you are granted:\n   a) The right to reproduce, modify, and distribute the Work\n   b) The right to create and distribute Derivative Works\n   c) The right to use the Work for commercial purposes\n\n5. Responsible AI Requirements. You agree to:\n   a) Not use the Work to harm or deceive others\n   b) Not use the Work to generate disinformation or misleading content\n   c) Respect privacy and data protection rights\n   d)"
  },
  {
    "title": "Auto-Retry Pattern",
    "path": "/advanced/auto-retry",
    "content": "\nAuto-Retry\n\nOverview\n\nAuto-retry is a resilience pattern that automatically attempts to recover from failed operations by repeating them based on configurable strategies. This pattern helps applications handle transient failures gracefully and maintain reliability in unreliable environments.\n\nReal-World Analogy\n\nThink of auto-retry like trying to make a phone call in an area with poor reception:\n\n- The first call attempt fails (operation failure)\n- You wait a moment before trying again (delay strategy)\n- Each subsequent attempt might wait longer (exponential backoff)\n- After several attempts, you might give up (maximum retries)\n- You might try alternative numbers (fallback mechanisms)\n\nCommon Use Cases\n\n1. **Network Requests**\n\n   - Problem: Temporary network connectivity issues\n   - Solution: Retry failed requests with increasing delays\n   - Benefit: Higher success rate for critical operations\n\n2. **Database Operations**\n\n   - Problem: Temporary database connection losses\n   - Soluti"
  },
  {
    "title": "Batch Throttling",
    "path": "/advanced/batch-throttling",
    "content": "\nBatch Throttling\n\nOverview\n\nBatch throttling is an advanced rate-limiting technique that groups multiple function calls or requests into batches and processes them together. This approach optimizes resource usage by reducing the total number of operations while still handling all requests efficiently.\n\nReal-World Analogy\n\nThink of batch throttling like a postal service's mail sorting system:\n\n- Individual letters (requests) arrive continuously\n- The sorting facility (batch processor) collects letters for a period\n- When enough letters accumulate or time elapses, they're processed together\n- Each batch is delivered efficiently as one unit\n- Resources are optimized by handling multiple items at once\n\nCommon Use Cases\n\n1. **Bulk API Operations**\n\n   - Problem: Many individual API calls causing network congestion\n   - Solution: Group related calls into single batch request\n   - Benefit: Reduced network overhead and better throughput\n\n2. **Database Operations**\n\n   - Problem: High frequenc"
  },
  {
    "title": "Browser Optimizations",
    "path": "/advanced/browser-optimizations",
    "content": "\nBrowser Optimizations\n\nOverview\n\nBrowser optimizations for async JavaScript focus on techniques to improve performance, responsiveness, and resource utilization in web applications. These optimizations leverage browser-specific APIs and features to enhance the user experience while managing system resources efficiently.\n\nKey Concepts\n\n1. DOM Batch Processing\n\nWhen handling multiple DOM updates, batching operations is crucial for performance:\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Pitfalls\n\n1. **Layout Thrashing**\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. **Event Handler Proliferation**\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\nConsider a web application that dynamically loads content as the user scrolls. Using IntersectionObserver and DOM batch processing, you can efficiently manage resource loading and DOM updates without blocking the main thread.\n\n::: code-with-tooltips\n\n\n\n:::\n\n3. DOM Element Tracking\n\nEfficient tracking of processed DOM elements using WeakSet\n\n::: code-with-tool"
  },
  {
    "title": "Debouncing",
    "path": "/advanced/debouncing",
    "content": "\nDebouncing\n\nOverview\n\nDebouncing is a programming practice that limits the rate at which a function can be called. Think of it like a \"cooling-off period\" for function calls. Instead of executing the function every time it's triggered, debouncing ensures the function only runs after a specified amount of time has passed since its last invocation.\n\nReal-World Analogy\n\nThink of debouncing like an elevator:\n\n- The action (closing doors) is delayed\n- Multiple triggers (button presses) during the delay are ignored\n- The action only happens after a period of no new triggers\n- This prevents constant starting/stopping\n- Resources are used efficiently\n\nCommon Use Cases\n\n1. **Search Input Fields**\n\n   - Problem: Each keystroke triggers an API call\n   - Solution: Wait until the user stops typing before making the call\n   - Benefit: Reduces server load and improves performance\n\n2. **Window Resize Events**\n\n   - Problem: Resize calculations run hundreds of times during resizing\n   - Solution: Only"
  },
  {
    "title": "Debugging Techniques",
    "path": "/advanced/debugging-techniques",
    "content": "\nDebugging Techniques\n\nOverview\n\nDebugging asynchronous JavaScript requires specialized techniques to track execution flow, handle timing issues, and understand state changes across async boundaries. These techniques help developers identify and fix issues in async code effectively.\n\nReal-World Analogy\n\nThink of async debugging like:\n\n1. **Detective Work**\n\n   - The detective (debugger) follows clues through time\n   - Crime scene photos (stack traces) capture moments\n   - The timeline (async execution) shows event sequence\n   - The witnesses (logs) provide additional context\n   - The evidence (state snapshots) reveals changes\n\n2. **Medical Diagnosis**\n\n   - Symptoms (errors) indicate problems\n   - Medical tests (debugging tools) gather data\n   - Patient history (logs) provides context\n   - Vital signs (state) show current condition\n   - Treatment monitoring (debugging) tracks progress\n\n3. **Automotive Repair**\n\n   - Diagnostic tools (debugger) identify issues\n   - Service history (logs"
  },
  {
    "title": "Error Handling Strategies",
    "path": "/advanced/error-handling",
    "content": "\nError Handling\n\nOverview\n\nEffective error handling is crucial for building robust applications. This section covers strategies for managing errors in JavaScript applications.\n\nKey Concepts\n\n1. Try-Catch Blocks\n\nUse try-catch blocks to handle synchronous errors and prevent application crashes.\n\n2. Promise Error Handling\n\nUse .catch() to handle errors in asynchronous operations.\n\nReal-World Example\n\nConsider a web application that fetches data from an API. Proper error handling ensures that network errors are gracefully managed.\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Pitfalls\n\n1. **Swallowing Errors**\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. **Uncaught Promise Rejections**\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Use centralized error handling for consistent error management.\n2. Log errors for debugging and analysis.\n3. Provide user-friendly error messages.\n"
  },
  {
    "title": "Advanced Async Patterns",
    "path": "/advanced/index",
    "content": "\nAdvanced Async Patterns\n\nOverview\n\nThis section covers advanced asynchronous patterns and techniques for JavaScript\nand TypeScript applications.\n\nPerformance Patterns\n\nRate Control\n\n- Auto-Retry - Automatic failure recovery with exponential\n  backoff\n- Batch Throttling - Efficient batch processing of API\n  calls\n- Debouncing - Delay execution until input settles\n- Throttling - Limit execution frequency\n- Memoization - Cache expensive operations\n\nMemory Management\n\n- Memory Management - Prevent memory leaks in async\n  code\n- Performance Monitoring - Track and optimize\n  async operations\n\nEnvironment-Specific Optimizations\n\n- Browser Optimizations - Browser-specific async\n  patterns\n- Node.js Optimizations - Node.js-specific async\n  patterns\n\nDevelopment Tools\n\n- Testing Strategies - Test async code effectively\n- Debugging Techniques - Debug async operations\n- Performance Profiling - Profile and optimize\n  async code\n\nError Management\n\n- Error Handling Strategies - Robust error handling"
  },
  {
    "title": "Memoization",
    "path": "/advanced/memoization",
    "content": "\nMemoization\n\nOverview\n\nMemoization is an optimization technique that speeds up applications by storing the results of expensive function calls and returning the cached result when the same inputs occur again. This technique trades memory space for improved performance by eliminating redundant computations.\n\nReal-World Analogy\n\nThink of memoization like a chef's mise en place (prepared ingredients):\n\n- Instead of chopping vegetables every time they're needed, the chef preps them once\n- The prepped ingredients (cached results) are stored and ready to use\n- When the same ingredient is needed again, it's immediately available\n- If a new ingredient is needed, it's prepared and added to the collection\n- Old, unused preparations might be discarded to save space (cache invalidation)\n\nCommon Use Cases\n\n1. **Complex Calculations**\n\n   - Problem: Expensive mathematical computations being repeated\n   - Solution: Cache results based on input parameters\n   - Benefit: Significant performance improve"
  },
  {
    "title": "Memory Management",
    "path": "/advanced/memory-management",
    "content": "\nMemory Management\n\nOverview\n\nEffective memory management is crucial for maintaining performance and stability in long-running applications. This section covers strategies to prevent memory leaks and optimize memory usage in JavaScript applications.\n\nKey Concepts\n\n1. Garbage Collection\n\nJavaScript engines automatically manage memory through garbage collection. However, developers must ensure that objects are no longer referenced when they are no longer needed.\n\n2. Memory Leaks\n\nCommon causes of memory leaks include:\n\n- Unintentionally retained references\n- Forgotten event listeners\n- Closures that capture unnecessary data\n\nReal-World Example\n\nConsider a web application that processes large datasets. Proper memory management ensures that memory is released after processing, preventing leaks.\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Pitfalls\n\n1. **Unintentional Global Variables**\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. **Forgotten Event Listeners**\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices"
  },
  {
    "title": "nodejs-optimizations",
    "path": "/advanced/nodejs-optimizations",
    "content": "Node.js Optimizations\n\nOverview\n\nNode.js optimizations focus on improving performance and resource utilization in server-side applications. This section covers techniques for optimizing Node.js applications.\n\nKey Concepts\n\n1. Event Loop Optimization\n\nEfficiently managing the event loop is crucial for high-performance Node.js applications.\n\n2. Resource Handling\n\nProperly managing resources such as file handles and network connections prevents resource leaks.\n\nReal-World Example\n\nConsider a Node.js application that handles multiple I/O operations. Optimizing resource handling ensures efficient throughput.\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Pitfalls\n\n1. **Blocking the Event Loop**\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. **Resource Leaks**\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Use asynchronous APIs to prevent blocking the event loop.\n2. Regularly profile and optimize resource usage.\n3. Use tools like Node.js Profiler and Clinic.js for performance analysis.\n"
  },
  {
    "title": "Performance Monitoring",
    "path": "/advanced/performance-monitoring",
    "content": "\nPerformance Monitoring\n\nOverview\n\nPerformance monitoring involves tracking and analyzing application performance to identify bottlenecks and optimize resource usage. This section covers tools and techniques for effective performance monitoring.\n\nKey Concepts\n\n1. Metrics Collection\n\nCollecting metrics such as response times, memory usage, and CPU load helps identify performance issues.\n\n2. Performance Timeline\n\nVisualizing performance data over time provides insights into application behavior and resource usage.\n\nReal-World Example\n\nConsider a web application that experiences slow response times. Performance monitoring can help identify the root cause and guide optimization efforts.\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Pitfalls\n\n1. **Ignoring Performance Data**\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. **Overhead from Monitoring**\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Use tools like Chrome DevTools and Lighthouse for performance analysis.\n2. Regularly review and optimize perfor"
  },
  {
    "title": "Performance Profiling",
    "path": "/advanced/performance-profiling",
    "content": "\nPerformance Profiling\n\nOverview\n\nPerformance profiling in async JavaScript involves analyzing and measuring code execution to identify bottlenecks, optimize resource usage, and improve overall application performance. This systematic approach helps developers make data-driven optimization decisions.\n\nReal-World Analogy\n\nThink of performance profiling like analyzing an athlete's training:\n\n- The stopwatch (timing) measures execution duration\n- The heart rate monitor (CPU usage) tracks system load\n- The video analysis (call stack) shows technique details\n- The training log (metrics) records all activities\n- The coach (profiler) identifies improvement areas\n\nCommon Use Cases\n\n1. **Bottleneck Identification**\n\n   - Problem: Unknown performance bottlenecks\n   - Solution: Systematic profiling and analysis\n   - Benefit: Data-driven optimization targets\n\n2. **Memory Leak Detection**\n\n   - Problem: Gradual memory growth\n   - Solution: Heap snapshots and allocation tracking\n   - Benefit: Early "
  },
  {
    "title": "Promisifying",
    "path": "/advanced/promisifying",
    "content": "\nPromisifying\n\nOverview\n\nPromisifying is the process of converting callback-based functions into Promise-based ones, enabling better async flow control and error handling. This technique helps modernize legacy code and provides a more consistent async programming model.\n\nReal-World Analogy\n\nThink of promisifying like modernizing an old factory:\n\n- Old machines (callbacks) work but are hard to coordinate\n- New control systems (promises) provide better oversight\n- The upgrade process (promisifying) maintains functionality\n- Modern interfaces (async/await) make operations smoother\n- Better error handling prevents production issues\n\nCommon Use Cases\n\n1. **Legacy API Integration**\n\n   - Problem: Callback-based APIs in modern async code\n   - Solution: Wrap callbacks in promises\n   - Benefit: Consistent async/await usage\n\n2. **Event to Promise Conversion**\n\n   - Problem: Event-based APIs needing promise interfaces\n   - Solution: Event wrapper promises\n   - Benefit: Simplified async flow contr"
  },
  {
    "title": "Testing Strategies",
    "path": "/advanced/testing-strategies",
    "content": "\nTesting Strategies\n\nOverview\n\nTesting asynchronous code requires specialized approaches to handle timing, state management, and non-deterministic behavior. These strategies ensure reliable testing of async operations while maintaining test readability and maintainability.\n\nReal-World Analogy\n\nThink of async testing like:\n\n1. **Quality Control Factory**\n\n   - The inspector (test runner) checks each product (function)\n   - Test fixtures simulate real materials (test data)\n   - Quality checkpoints (assertions) verify results\n   - Time studies (async utilities) manage operation timing\n   - Documentation (test reports) tracks all results\n\n2. **Scientific Laboratory**\n\n   - Experiments (test cases) verify hypotheses\n   - Control groups (test isolation) ensure accuracy\n   - Measurement tools (assertions) validate results\n   - Lab protocols (test procedures) ensure consistency\n   - Research papers (documentation) record findings\n\n3. **Aircraft Testing**\n\n   - Pre-flight checks (unit tests)\n  "
  },
  {
    "title": "Throttling",
    "path": "/advanced/throttling",
    "content": "\nThrottling\n\nOverview\n\nThrottling is a rate-limiting technique that controls how many times a function can be called within a specified time period. Unlike debouncing which waits for a quiet period, throttling ensures a function executes at a regular interval, even if it's being called more frequently.\n\nReal-World Analogy\n\nThink of throttling like a water faucet with a flow restrictor:\n\n- Water (function calls) constantly tries to flow through\n- The restrictor (throttle) limits the flow rate\n- No matter how much pressure (how many calls), the flow remains constant\n- Excess water (calls) is discarded\n- The flow rate (execution rate) remains steady and predictable\n\nCommon Use Cases\n\n1. **Scroll Event Handlers**\n\n   - Problem: Scroll events fire hundreds of times per second\n   - Solution: Limit processing to every X milliseconds\n   - Benefit: Smooth scrolling and better performance\n\n2. **Game Input Processing**\n\n   - Problem: Player actions happening too rapidly\n   - Solution: Enforce min"
  },
  {
    "title": "API Reference",
    "path": "/api/index",
    "content": "\nAPI Reference\n\nOverview\n\nThis documentation covers the core APIs and implementations provided by the library.\n\nCore APIs\n\nPromise Implementations\n\n- Custom Promise\n- Promise.all()\n- Promise.any()\n- Promise.race()\n- Promise.allSettled()\n\nPattern APIs\n\n- Auto Retry\n- Batch Throttling\n- Debouncing\n- Throttling\n- Memoization\n\nTimer APIs\n\n- setTimeout\n- setInterval\n- Clear Timers\n\nType Definitions\n\nFor detailed type definitions and interfaces, please refer to the TypeScript\ndeclaration files in the source code.\n"
  },
  {
    "title": "Async Control Flow Guide",
    "path": "/async/control-flow",
    "content": "\nControl Flow\n\nLearn how to manage asynchronous control flow in JavaScript.\n\nSequential Flow\n\nExecute operations in sequence:\n\n::: code-with-tooltips\n\n\n\n:::\n\nParallel Flow\n\nExecute operations in parallel:\n\n::: code-with-tooltips\n\n\n\n:::\n\nRace Conditions\n\nHandle race conditions properly:\n\n::: code-with-tooltips\n\n\n\n:::\n\nState Machine\n\nImplement an async state machine:\n\n::: code-with-tooltips\n\n\n\n:::\n\nEvent Sequencing\n\nControl event sequence and timing:\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. **Flow Control**\n\n   - Choose appropriate execution patterns\n   - Handle dependencies correctly\n   - Manage concurrency effectively\n\n2. **State Management**\n\n   - Use state machines for complex flows\n   - Handle transitions atomically\n   - Maintain clear state boundaries\n\n3. **Race Conditions**\n\n   - Implement proper cancellation\n   - Handle out-of-order responses\n   - Use request identifiers\n\n4. **Error Handling**\n\n   - Implement proper error boundaries\n   - Handle state transitions on erro"
  },
  {
    "title": "Async Error Handling Guide",
    "path": "/async/error-handling",
    "content": "\nError Handling\n\nLearn how to effectively handle errors in asynchronous JavaScript code.\n\nCustom Error Types\n\nCreate specific error types for better error handling:\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Boundaries\n\nImplement error boundaries for async operations:\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Recovery\n\nImplement graceful error recovery:\n\n::: code-with-tooltips\n\n\n\n:::\n\nCircuit Breaker\n\nImplement a circuit breaker pattern:\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Aggregation\n\nHandle multiple errors gracefully:\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. **Error Types**\n\n   - Create specific error classes\n   - Include relevant error details\n   - Maintain proper prototype chain\n\n2. **Error Recovery**\n\n   - Implement retry mechanisms\n   - Provide fallback options\n   - Use circuit breakers for unstable services\n\n3. **Error Boundaries**\n\n   - Contain error propagation\n   - Implement proper cleanup\n   - Log errors appropriately\n\n4. **Error Context**\n\n   - Include relevant error det"
  },
  {
    "title": "Async JavaScript Patterns",
    "path": "/async/index",
    "content": "\nAsync JavaScript Patterns\n\nMaster asynchronous programming in JavaScript with comprehensive patterns and examples.\n\nCore Concepts\n\n- **Promises**: Understanding the Promise API and its patterns\n- **Async/Await**: Modern asynchronous programming\n- **Error Handling**: Proper error management in async code\n- **Performance**: Optimizing async operations\n\nAvailable Guides\n\nPromise Patterns\n\n- Custom Promises - Creating custom Promise wrappers\n- Promise.all - Parallel execution patterns\n- Promise.race - Racing promises\n- Promise.any - First success patterns\n- Promise.allSettled - Complete settlement patterns\n- Promise.finally - Cleanup patterns\n- Promisifying - Converting callbacks to promises\n\nTask Management\n\n- Parallel Tasks - Running tasks in parallel\n- Sequential Tasks - Running tasks in sequence\n- Racing Tasks - Implementing task races\n\nTimer Patterns\n\n- Timer Management - Managing timers effectively\n- Custom setTimeout - Custom timeout implementations\n- Custom setInterval - Custom in"
  },
  {
    "title": "Async Performance Guide",
    "path": "/async/performance",
    "content": "\nPerformance\n\nLearn how to optimize asynchronous operations for better performance.\n\nCaching Results\n\nImplement efficient caching for async operations:\n\n::: code-with-tooltips\n\n\n\n:::\n\nRequest Batching\n\nBatch multiple requests for better performance:\n\n::: code-with-tooltips\n\n\n\n:::\n\nResource Pooling\n\nManage resource pools for better performance:\n\n::: code-with-tooltips\n\n\n\n:::\n\nMemory Management\n\nImplement memory-efficient processing:\n\n::: code-with-tooltips\n\n\n\n:::\n\nPerformance Monitoring\n\nMonitor async operation performance:\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. **Caching Strategy**\n\n   - Implement appropriate TTL\n   - Use stale-while-revalidate\n   - Monitor cache hit rates\n\n2. **Resource Management**\n\n   - Pool expensive resources\n   - Implement proper cleanup\n   - Monitor resource usage\n\n3. **Batch Processing**\n\n   - Group related operations\n   - Set appropriate batch sizes\n   - Handle partial failures\n\n4. **Memory Efficiency**\n\n   - Use streaming for large datasets\n   - I"
  },
  {
    "title": "JavaScript Promise Patterns",
    "path": "/async/promises",
    "content": "\nPromise Patterns\n\nLearn how to effectively work with Promises in JavaScript.\n\nBasic Promise Usage\n\nCreate and work with Promises:\n\n::: code-with-tooltips\n\n\n\n:::\n\nPromise Combinators\n\nUsing Promise combination methods:\n\n::: code-with-tooltips\n\n\n\n:::\n\nPromise Chaining\n\nChain multiple operations:\n\n::: code-with-tooltips\n\n\n\n:::\n\nCustom Promise Wrappers\n\nCreate reusable Promise patterns:\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Handling\n\nHandle Promise errors effectively:\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. **Promise Creation**\n\n   - Only create new Promises when wrapping async operations\n   - Avoid unnecessary Promise wrapping\n   - Use async/await for cleaner code\n\n2. **Error Handling**\n\n   - Always handle Promise rejections\n   - Use specific error types\n   - Implement proper error recovery\n\n3. **Performance**\n\n   - Use appropriate Promise combinators\n   - Avoid unnecessary Promise chains\n   - Consider caching Promise results\n\n4. **Code Organization**\n   - Keep Promise chains "
  },
  {
    "title": "Task Management in JavaScript",
    "path": "/async/tasks",
    "content": "\nTask Management\n\nLearn how to effectively manage multiple asynchronous tasks in JavaScript.\n\nSequential Tasks\n\nExecute tasks one after another:\n\n::: code-with-tooltips\n\n\n\n:::\n\nParallel Tasks\n\nExecute tasks concurrently with control:\n\n::: code-with-tooltips\n\n\n\n:::\n\nTask Batching\n\nProcess tasks in batches:\n\n::: code-with-tooltips\n\n\n\n:::\n\nTask Cancellation\n\nImplement cancellable tasks:\n\n::: code-with-tooltips\n\n\n\n:::\n\nTask Queue\n\nImplement a task queue with priorities:\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. **Task Organization**\n\n   - Group related tasks logically\n   - Consider task dependencies\n   - Implement proper error boundaries\n\n2. **Resource Management**\n\n   - Control concurrency levels\n   - Implement proper cancellation\n   - Clean up resources after completion\n\n3. **Error Handling**\n\n   - Handle individual task failures\n   - Implement retry strategies\n   - Provide meaningful error context\n\n4. **Performance**\n\n   - Balance concurrency vs resources\n   - Use appropriate b"
  },
  {
    "title": "JavaScript Timer Patterns",
    "path": "/async/timers",
    "content": "\nTimer Patterns\n\nLearn how to effectively work with timers and intervals in JavaScript.\n\nPromise-based Delay\n\nCreate a delay using Promises:\n\n\n\nCancellable Timer\n\nCreate a cancellable timer:\n\n\n\nInterval Handler\n\nCreate a manageable interval:\n\n\n\nDebounce Timer\n\nImplement a debounce function:\n\n\n\nThrottle Timer\n\nImplement a throttle function:\n\n\n\nBest Practices\n\n1. **Timer Management**\n\n   - Always clean up timers when they're no longer needed\n   - Use appropriate intervals to avoid performance issues\n   - Consider using requestAnimationFrame for animations\n\n2. **Error Handling**\n\n   - Handle timer cancellation gracefully\n   - Implement proper cleanup in error cases\n   - Consider edge cases like browser tab visibility\n\n3. **Performance**\n\n   - Use debounce for high-frequency events\n   - Use throttle for continuous events\n   - Avoid creating unnecessary timers\n\n4. **Memory Management**\n   - Clear intervals and timeouts to prevent memory leaks\n   - Remove event listeners when components unmo"
  },
  {
    "title": "Custom setInterval Implementation",
    "path": "/examples/async/control-flow/custom-setinterval",
    "content": "\nCustom setInterval Examples\n\nLearn how to create and use custom setInterval implementations with advanced features.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nDynamic Interval\n\n::: code-with-tooltips\n\n\n\n:::\n\nPrecise Interval\n\n::: code-with-tooltips\n\n\n\n:::\n\nThrottled Interval\n\n::: code-with-tooltips\n\n\n\n:::\n\nBatch Interval\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Custom setTimeout Implementation",
    "path": "/examples/async/control-flow/custom-settimeout",
    "content": "\nCustom setTimeout Examples\n\nLearn how to create and use custom setTimeout implementations with advanced features.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nRecursive setTimeout\n\n::: code-with-tooltips\n\n\n\n:::\n\nPriority Queue Timeout\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdaptive Timeout\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Timer Management Patterns",
    "path": "/examples/async/control-flow/timer-management",
    "content": "\nTimer Management Examples\n\nLearn how to effectively manage timers in asynchronous JavaScript applications.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nTimer Manager\n\n::: code-with-tooltips\n\n\n\n:::\n\nInterval Manager\n\n::: code-with-tooltips\n\n\n\n:::\n\nDebounced Timer\n\n::: code-with-tooltips\n\n\n\n:::\n\nProgressive Timer\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Auto-Retry Pattern Implementation",
    "path": "/examples/async/performance/auto-retry",
    "content": "\nAuto-Retry Examples\n\nLearn how to implement robust retry mechanisms for handling transient failures.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nConfigurable Retry Strategy\n\n::: code-with-tooltips\n\n\n\n:::\n\nCircuit Breaker with Retry\n\n::: code-with-tooltips\n\n\n\n:::\n\nRetry Queue\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Batch Throttling Pattern Implementation",
    "path": "/examples/async/performance/batch-throttling",
    "content": "\nBatch Throttling Examples\n\nLearn how to implement batch processing with throttling for better performance and resource management.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nThrottled Batch Processor\n\n::: code-with-tooltips\n\n\n\n:::\n\nConcurrent Batch Processor\n\n::: code-with-tooltips\n\n\n\n:::\n\nPriority Batch Processor\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Debouncing Pattern Implementation",
    "path": "/examples/async/performance/debouncing",
    "content": "\nDebouncing Examples\n\nLearn how to implement debouncing patterns for rate limiting and performance optimization.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nPromise-based Debounce\n\n::: code-with-tooltips\n\n\n\n:::\n\nDebounce with Queue\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdaptive Debounce\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Memoization Pattern Implementation",
    "path": "/examples/async/performance/memoization",
    "content": "\nMemoization Examples\n\nLearn how to implement memoization patterns for caching and performance optimization.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nLRU Cache Memoization\n\n::: code-with-tooltips\n\n\n\n:::\n\nTime-based Memoization\n\n::: code-with-tooltips\n\n\n\n:::\n\nSmart Memoization\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Throttling Pattern Implementation",
    "path": "/examples/async/performance/throttling",
    "content": "\nThrottling Examples\n\nLearn how to implement throttling patterns for rate limiting and performance optimization.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nPromise-based Throttle\n\n::: code-with-tooltips\n\n\n\n:::\n\nRate Limiter\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdaptive Throttle\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Custom Promise Implementation Guide",
    "path": "/examples/async/promises/custom-promise-usage",
    "content": "\nCustom Promise Usage Examples\n\nLearn how to create and use custom Promise wrappers for better control over asynchronous operations.\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdditional Examples\n\nCancellable Promise\n\n::: code-with-tooltips\n\n\n\n:::\n\nRetryable Promise\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Promise.all Pattern Examples",
    "path": "/examples/async/promises/promise-all",
    "content": "\nPromise.all Examples\n\nLearn how to use `Promise.all` for parallel execution patterns.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nParallel with Concurrency Limit\n\n::: code-with-tooltips\n\n\n\n:::\n\nBatch Processing\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Handling with Partial Results\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Promise.allSettled Pattern Examples",
    "path": "/examples/async/promises/promise-allsettled",
    "content": "\nPromise.allSettled Examples\n\nLearn how to use `Promise.allSettled` for handling multiple promises regardless of their outcome.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nBatch Processing with Results Analysis\n\n::: code-with-tooltips\n\n\n\n:::\n\nRetry Failed Operations\n\n::: code-with-tooltips\n\n\n\n:::\n\nProgress Tracking\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Promise.any Pattern Examples",
    "path": "/examples/async/promises/promise-any",
    "content": "\nPromise.any Examples\n\nLearn how to use `Promise.any` for handling the first successful promise resolution.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nService Discovery\n\n::: code-with-tooltips\n\n\n\n:::\n\nResource Loading with Fallbacks\n\n::: code-with-tooltips\n\n\n\n:::\n\nAuthentication with Multiple Providers\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Promise.finally Pattern Examples",
    "path": "/examples/async/promises/promise-finally",
    "content": "\nPromise.finally Examples\n\nLearn how to use `Promise.finally` for cleanup and resource management.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nDatabase Connection Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nTimer Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nFile Handle Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nMutex Lock Management\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Promise.race Pattern Examples",
    "path": "/examples/async/promises/promise-race",
    "content": "\nPromise.race Examples\n\nLearn how to use `Promise.race` for implementing timeouts and racing conditions.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nTimeout with Cleanup\n\n::: code-with-tooltips\n\n\n\n:::\n\nRace with Fallback\n\n::: code-with-tooltips\n\n\n\n:::\n\nRace with Progress Updates\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Promisifying Pattern Guide",
    "path": "/examples/async/promises/promisifying",
    "content": "\nPromisifying Examples\n\nLearn how to convert callback-based APIs into Promise-based ones.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nGeneric Promisification\n\n::: code-with-tooltips\n\n\n\n:::\n\nClass Method Promisification\n\n::: code-with-tooltips\n\n\n\n:::\n\nEvent Emitter Promisification\n\n::: code-with-tooltips\n\n\n\n:::\n\nBatch Promisification\n\n::: code-with-tooltips\n\n\n\n:::\n\nPromisification with Cancellation\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Parallel Task Execution Patterns",
    "path": "/examples/async/tasks/parallel",
    "content": "\nParallel Task Examples\n\nfor (let i = 0; i < tasks.length; i++) {\nconst promise = executor(i);\nexecuting.add(promise);\npromise.then(() => executing.delete(promise));\n\n    if (executing.size >= concurrency) {\n      await Promise.race(executing);\n    }\n\n}\n\nawait Promise.all(executing);\nreturn results;\n}\n\n\n"
  },
  {
    "title": "Racing Task Execution Patterns",
    "path": "/examples/async/tasks/racing",
    "content": "\nRacing Task Execution Examples\n\nLearn how to implement racing patterns for competitive task execution.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nRace with Cleanup\n\n::: code-with-tooltips\n\n\n\n:::\n\nProgressive Racing\n\n::: code-with-tooltips\n\n\n\n:::\n\nCompetitive Racing\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Sequential Task Execution Patterns",
    "path": "/examples/async/tasks/sequential",
    "content": "\nSequential Task Execution Examples\n\nLearn how to execute tasks in sequence with proper error handling and state management.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nPipeline Processing\n\n::: code-with-tooltips\n\n\n\n:::\n\nState Machine Execution\n\n::: code-with-tooltips\n\n\n\n:::\n\nDependency-Based Execution\n\n::: code-with-tooltips\n\n\n\n:::\n\nRetry with Backoff\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Auto-Retry Examples",
    "path": "/examples/auto-retry-examples",
    "content": "\nAuto-Retry Examples\n\nThis page demonstrates practical examples of implementing and using auto-retry patterns for handling transient failures.\n\nBasic Retry Implementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Retry Strategy\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Resilient API Client\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Circuit breaker pattern:\n\n   \n\n2. Retry with jitter:\n\n   \n\n3. Retry budget:\n\n   \n\n4. Retry with fallback:\n\n   \n"
  },
  {
    "title": "Batch Throttling Examples",
    "path": "/examples/batch-throttling-examples",
    "content": "\nBatch Throttling Examples\n\nThis page demonstrates practical examples of implementing and using batch throttling patterns for efficient API calls and resource management.\n\nBasic Batch Processor\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Batch Throttling\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Rate-Limited API Client\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Dynamic batch sizing:\n\n   \n\n2. Priority queuing:\n\n   \n\n3. Resource monitoring:\n\n   \n\n4. Circuit breaking:\n\n   \n"
  },
  {
    "title": "Browser Optimization Examples",
    "path": "/examples/browser-optimization-examples",
    "content": "\nBrowser Optimization Examples\n\nThis page demonstrates practical examples of optimizing asynchronous operations in the browser environment.\n\nDOM Batch Processing\n\n::: code-with-tooltips\n\n\n\n:::\n\nIntersection Observer\n\n::: code-with-tooltips\n\n\n\n:::\n\nWeb Worker Task Queue\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Virtual Scrolling\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Frame timing:\n\n   \n\n2. Memory management:\n\n   \n\n3. Event delegation:\n\n   \n\n4. Idle scheduling:\n\n   \n"
  },
  {
    "title": "Custom Promise Usage Examples",
    "path": "/examples/custom-promise-usage",
    "content": "\nCustom Promise Usage Examples\n\nThis page demonstrates practical examples of using our custom Promise implementation.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nChaining Operations\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Handling\n\n::: code-with-tooltips\n\n\n\n:::\n\nAsync/Await Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: API Client\n\n::: code-with-tooltips\n\n\n\n:::\n\nTesting Custom Promises\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Always handle rejections:\n\n   \n\n2. Use TypeScript for better type safety:\n\n   \n\n3. Chain promises appropriately:\n\n   \n\n4. Proper error propagation:\n\n   \n"
  },
  {
    "title": "Custom setInterval Examples",
    "path": "/examples/custom-setinterval",
    "content": "\nCustom setInterval Examples\n\nThis page demonstrates practical examples of implementing and using custom setInterval functionality with enhanced features and better control.\n\nBasic Implementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nPausable Interval\n\n::: code-with-tooltips\n\n\n\n:::\n\nDynamic Interval\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Polling Service\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Memory leak prevention:\n\n   \n\n2. Error handling:\n\n   \n\n3. Performance monitoring:\n\n   \n\n4. Resource management:\n\n   \n"
  },
  {
    "title": "Custom setTimeout Examples",
    "path": "/examples/custom-settimeout",
    "content": "\nCustom setTimeout Examples\n\nThis page demonstrates practical examples of implementing and using custom setTimeout functionality with enhanced features and better control.\n\nBasic Implementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nPromise-based Timer\n\n::: code-with-tooltips\n\n\n\n:::\n\nRetry Timer\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Rate Limited API Client\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Cleanup handling:\n\n   \n\n2. Error handling:\n\n   \n\n3. Resource management:\n\n   \n\n4. Debounce utility:\n\n   \n"
  },
  {
    "title": "Debouncing Examples",
    "path": "/examples/debouncing-examples",
    "content": "\nDebouncing Examples\n\nThis page demonstrates practical examples of implementing and using debouncing patterns to handle rapid-fire events efficiently.\n\nBasic Debouncing\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Debouncing\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Form Validation\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Cancellable debounce:\n\n   \n\n2. Resource cleanup:\n\n   \n\n3. Performance monitoring:\n\n   \n\n4. Error boundaries:\n\n   \n"
  },
  {
    "title": "Error Handling Examples",
    "path": "/examples/error-handling-examples",
    "content": "\nError Handling Examples\n\nThis page demonstrates practical examples of implementing and using error handling patterns for asynchronous operations.\n\nBasic Error Handling\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Error Handling\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: API Error Handling\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Error aggregation:\n\n   \n\n2. Context preservation:\n\n   \n\n3. Error recovery:\n\n   \n\n4. Error monitoring:\n\n   \n"
  },
  {
    "title": "Code Examples",
    "path": "/examples/index",
    "content": "\nThis section provides comprehensive, practical examples of all async patterns and implementations covered in this project. Each example is designed to demonstrate real-world usage and best practices.\n\nPromise Examples\n\nLearn how to use various Promise implementations:\n\n::: code-with-tooltips\n\n\n\n:::\n\nTask Pattern Examples\n\nImplement common async task patterns:\n\n\n\nTimer Examples\n\nEnhanced timer implementations:\n\n\n\nAdvanced Pattern Examples\n\nSophisticated async patterns for real-world scenarios:\n\n\n\nPerformance Examples\n\nOptimize async operations:\n\n\n\nReal-World Examples\n\nComplete implementations of common scenarios:\n\n\n\nEach example category has its own dedicated page with more detailed explanations, use cases, and best practices. Navigate through the sidebar to explore specific examples in depth.\n"
  },
  {
    "title": "Linting Test Examples",
    "path": "/examples/lint-test",
    "content": "\nLinting Test Examples\n\nTypeScript Example with Issues\n\n::: code-with-tooltips\n\n\n\n:::\n\nJavaScript Example with Issues\n\n::: code-with-tooltips\n\n\n\n:::\n\nGood TypeScript Example\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Linting Examples",
    "path": "/examples/linting-example",
    "content": "\nLinting Examples\n\nThis example shows some common TypeScript/JavaScript linting issues.\n\nBad Code Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nGood Code Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Issues\n\n1. Extra spaces in function declarations\n2. Using `any` type\n3. Incorrect indentation\n4. Double quotes instead of single quotes\n5. Unused variables\n6. Missing semicolons\n7. Console.log usage\n8. Inconsistent spacing around operators\n"
  },
  {
    "title": "Markdown Linting Examples",
    "path": "/examples/markdown-lint-test",
    "content": "\nMarkdown Linting Examples\n\nThis line has been shortened to meet the 80-character line length limit for better\nreadability.\n\n- Correct list style (using dash)\n- Consistent spacing\n  - Correct indentation\n\n::: code-with-tooltips\n\n\n\n:::\n\nCorrect Header Level\n\nThis is JavaScript and Node.js with proper capitalization.\n\n- Correct indentation\n- Consistent list items\n- Proper spacing\n\n**Important Note:** Using bold instead of HTML heading\n\nExample Link\n\n_Correct emphasis style_ vs _correct emphasis style_\n\nSecond Level Heading\n"
  },
  {
    "title": "Memoization Examples",
    "path": "/examples/memoization-examples",
    "content": "\nMemoization Examples\n\nThis page demonstrates practical examples of implementing and using memoization patterns to cache function results for better performance.\n\nBasic Memoization\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Memoization\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: API Response Caching\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Async memoization:\n\n   \n\n2. Weak reference caching:\n\n   \n\n3. Composite key generation:\n\n   \n\n4. Selective caching:\n\n   \n"
  },
  {
    "title": "Memory Management Examples",
    "path": "/examples/memory-management-examples",
    "content": "\nMemory Management Examples\n\nThis page demonstrates practical examples of managing memory efficiently in asynchronous operations.\n\nObject Pool\n\n::: code-with-tooltips\n\n\n\n:::\n\nWeakRef Cache\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Memory-Efficient Data Processing\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Memory monitoring:\n\n   \n\n2. Garbage collection hooks:\n\n   \n\n3. Memory leak detection:\n\n   \n\n4. Resource limits:\n\n   \n"
  },
  {
    "title": "Node.js Optimization Examples",
    "path": "/examples/nodejs-optimization-examples",
    "content": "\nNode.js Optimization Examples\n\nThis page demonstrates practical examples of optimizing asynchronous operations in Node.js environments.\n\nStream Processing\n\n::: code-with-tooltips\n\n\n\n:::\n\nWorker Threads Pool\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Batch Processing Service\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Memory management:\n\n   \n\n2. Event loop monitoring:\n\n   \n\n3. Resource pooling:\n\n   \n\n4. Graceful shutdown:\n\n   \n"
  },
  {
    "title": "Parallel Tasks Examples",
    "path": "/examples/parallel-tasks",
    "content": "\nParallel Tasks Examples\n\nThis page demonstrates practical examples of executing tasks in parallel while managing concurrency and resources effectively.\n\nBasic Parallel Execution\n\n::: code-with-tooltips\n\n\n\n:::\n\nConcurrent Task Queue\n\n::: code-with-tooltips\n\n\n\n:::\n\nBatch Processing with Concurrency\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Parallel Data Processing Pipeline\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Resource management:\n\n   \n\n2. Error handling:\n\n   \n\n3. Progress monitoring:\n\n   \n\n4. Cancellation support:\n\n   \n"
  },
  {
    "title": "Performance Monitoring Examples",
    "path": "/examples/performance-monitoring-examples",
    "content": "\nPerformance Monitoring Examples\n\nThis page demonstrates practical examples of implementing and using performance monitoring patterns for tracking and analyzing application performance.\n\nBasic Performance Monitoring\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Performance Monitoring\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: API Performance Monitoring\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Memory monitoring:\n\n   \n\n2. CPU profiling:\n\n   \n\n3. Event loop monitoring:\n\n   \n\n4. Resource utilization:\n\n   \n"
  },
  {
    "title": "Promise.all Examples",
    "path": "/examples/promise-all-examples",
    "content": "\nPromise.all Examples\n\nThis page demonstrates practical examples of using `Promise.all` for parallel execution.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Handling\n\n::: code-with-tooltips\n\n\n\n:::\n\nData Aggregation\n\n::: code-with-tooltips\n\n\n\n:::\n\nBatch Processing\n\n::: code-with-tooltips\n\n\n\n:::\n\nResource Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Data Synchronization\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Error handling:\n\n   \n\n2. Progress tracking:\n\n   \n\n3. Resource cleanup:\n\n   \n\n4. Timeout handling:\n\n   \n"
  },
  {
    "title": "Promise.allSettled Examples",
    "path": "/examples/promise-allsettled-examples",
    "content": "\nPromise.allSettled Examples\n\nThis page demonstrates practical examples of using `Promise.allSettled` to handle multiple promises and get all their results, regardless of success or failure.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nBatch Processing with Status\n\n::: code-with-tooltips\n\n\n\n:::\n\nData Validation System\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: System Health Check\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Type handling:\n\n   \n\n2. Error aggregation:\n\n   \n\n3. Progress tracking:\n\n   \n\n4. Cleanup handling:\n\n   \n"
  },
  {
    "title": "Promise.any Examples",
    "path": "/examples/promise-any-examples",
    "content": "\nPromise.any Examples\n\nThis page demonstrates practical examples of using `Promise.any` to handle multiple promises and take the first successful result.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nFallback Mechanisms\n\n::: code-with-tooltips\n\n\n\n:::\n\nAuthentication System\n\n::: code-with-tooltips\n\n\n\n:::\n\nResource Loading\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Service Discovery\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Always handle AggregateError:\n\n   \n\n2. Implement proper logging:\n\n   \n\n3. Consider timeouts:\n\n   \n\n4. Implement fallback mechanisms:\n\n   \n"
  },
  {
    "title": "Promise.finally Examples",
    "path": "/examples/promise-finally-examples",
    "content": "\nPromise.finally Examples\n\nThis page demonstrates practical examples of using `Promise.finally` for cleanup and guaranteed execution scenarios.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nResource Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nUI State Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nFile Handling\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: API Request Handler\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Always use finally for cleanup:\n\n   \n\n2. Handle nested resources:\n\n   \n\n3. Combine with other Promise methods:\n\n   \n\n4. State management:\n\n   \n"
  },
  {
    "title": "Promise.race Examples",
    "path": "/examples/promise-race-examples",
    "content": "\nPromise.race Examples\n\nThis page demonstrates practical examples of using `Promise.race` for competitive execution.\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nMultiple Data Sources\n\n::: code-with-tooltips\n\n\n\n:::\n\nResource Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nUser Interaction Timeouts\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Service Discovery\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Always include timeouts:\n\n   \n\n2. Handle errors appropriately:\n\n   \n\n3. Clean up resources:\n\n   \n\n4. Consider cancellation:\n\n   \n"
  },
  {
    "title": "Promisifying Examples",
    "path": "/examples/promisifying-examples",
    "content": "\nPromisifying Examples\n\nThis page demonstrates practical examples of converting callback-based APIs to Promise-based APIs.\n\nBasic Promisification\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Promisification\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Legacy API Wrapper\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Error handling:\n\n   \n\n2. Timeout handling:\n\n   \n\n3. Resource cleanup:\n\n   \n\n4. Event handling:\n\n   \n"
  },
  {
    "title": "Racing Tasks Examples",
    "path": "/examples/racing-tasks",
    "content": "\nRacing Tasks Examples\n\nThis page demonstrates practical examples of executing tasks in a racing pattern, where the first task to complete determines the outcome.\n\nBasic Racing Pattern\n\n::: code-with-tooltips\n\n\n\n:::\n\nMultiple Data Sources\n\n::: code-with-tooltips\n\n\n\n:::\n\nService Discovery\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Load Balancer\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Timeout handling:\n\n   \n\n2. Cancellation support:\n\n   \n\n3. Error handling:\n\n   \n\n4. Resource cleanup:\n\n   \n"
  },
  {
    "title": "Sequential Tasks Examples",
    "path": "/examples/sequential-tasks",
    "content": "\nSequential Tasks Examples\n\nThis page demonstrates practical examples of executing tasks in sequence, ensuring each task completes before the next begins.\n\nBasic Sequential Execution\n\n::: code-with-tooltips\n\n\n\n:::\n\nData Pipeline Processing\n\n::: code-with-tooltips\n\n\n\n:::\n\nDependency Resolution\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: User Registration Flow\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Error handling with partial completion:\n\n   \n\n2. Progress tracking:\n\n   \n\n3. Timeout handling:\n\n   \n\n4. Resource management:\n\n   \n"
  },
  {
    "title": "Throttling Examples",
    "path": "/examples/throttling-examples",
    "content": "\nThrottling Examples\n\nThis page demonstrates practical examples of implementing and using throttling patterns to limit the rate of function execution.\n\nBasic Throttling\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Throttling\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Rate Limited API Client\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Window-based throttling:\n\n   \n\n2. Resource-aware throttling:\n\n   \n\n3. Priority throttling:\n\n   \n\n4. Adaptive throttling:\n\n   \n"
  },
  {
    "title": "Timer Management Examples",
    "path": "/examples/timer-management",
    "content": "\nTimer Management Examples\n\nThis page demonstrates practical examples of managing multiple timers, including cleanup, synchronization, and resource management.\n\nTimer Registry\n\n::: code-with-tooltips\n\n\n\n:::\n\nTimer Group Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example: Task Scheduler\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Resource cleanup:\n\n   \n\n2. Error boundaries:\n\n   \n\n3. Performance tracking:\n\n   \n\n4. Memory management:\n\n   \n"
  },
  {
    "title": "Tooltip System Guide",
    "path": "/examples/tooltip-system",
    "content": "\nTooltip System Guide\n\nOverview\n\nOur tooltip system provides a flexible, performant way to add contextual information throughout the application. It supports both hover and click interactions, handles positioning automatically, and integrates with our portal system for optimal rendering.\n\nQuick Start\n\nBasic Usage\n\nThe simplest way to add a tooltip is using the `has-tooltip` class:\n\n::: code-with-tooltips\n\n\n\n:::\n\nAd-hoc Tooltips\n\nFor more complex tooltips, use the `createAdHocTooltip` function:\n\n::: code-with-tooltips\n\n\n\n:::\n\nSystem Architecture\n\nComponents\n\n1. **Portal System**\n\n   - Manages tooltip rendering outside component trees\n   - Prevents z-index and overflow issues\n   - Handles positioning and stacking\n\n2. **Event Management**\n\n   - Tracks hover and click interactions\n   - Manages tooltip lifecycle\n   - Handles cleanup and memory management\n\n3. **Positioning Engine**\n   - Calculates optimal tooltip placement\n   - Handles viewport boundaries\n   - Manages scroll containers\n\nTest"
  },
  {
    "title": "Configuration Guide",
    "path": "/guide/configuration",
    "content": "\nConfiguration Guide\n\nCode Quality Tools\n\n1. ESLint Configuration\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Prettier Configuration\n\n::: code-with-tooltips\n\n\n\n:::\n\n3. Husky Setup\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\n4. Commitlint Configuration\n\n::: code-with-tooltips\n\n\n\n:::\n\n5. Jest Configuration\n\n::: code-with-tooltips\n\n\n\n:::\n\n6. GitHub Actions Workflow\n\n::: code-with-tooltips\n\n\n\n:::\n\nDevelopment Environment\n\nVS Code Settings\n\n::: code-with-tooltips\n\n\n\n:::\n\nVS Code Extensions\n\n::: code-with-tooltips\n\n\n\n:::\n\nPackage Scripts\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Getting Started",
    "path": "/guide/getting-started",
    "content": "\nGetting Started\n\nOverview\n\nA comprehensive collection of async JavaScript patterns and implementations,\nwith TypeScript support and best practices.\n\nInstallation\n\n::: code-with-tooltips\n\n\n\n:::\n\nQuick Start\n\n::: code-with-tooltips\n\n\n\n:::\n\nPattern Categories\n\nPromise Implementations\n\n- Custom Promise - Build your own Promise from scratch\n- Promise.all() - Parallel execution with all promises\n- Promise.any() - Race to first success\n- Promise.race() - Race to first completion\n- Promise.allSettled() - Wait for all completions\n- Promise.finally() - Guaranteed execution\n- Promise.resolve/reject - Static promise creation\n\nTask Management\n\n- Tasks in Series - Sequential execution\n- Tasks in Parallel - Concurrent execution\n- Tasks Racing - Competitive execution\n\nTimer Control\n\n- Custom setTimeout - Enhanced timeout implementation\n- Custom setInterval - Enhanced interval implementation\n- Clear All Timers - Timer management\n\nRate Control\n\n- Auto-Retry - Automatic failure recovery\n- Batch Throttli"
  },
  {
    "title": "Custom Promise Implementation",
    "path": "/implementations/custom-promise",
    "content": "\nCustom Promise Implementation\n\nOverview\n\nLearn how to build your own Promise implementation from scratch. This guide\ncovers the core functionality of Promises, including state management, chaining,\nand error handling.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nChaining Promises\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Handling\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Features\n\n1. **State Management**\n\n   - Maintains promise state (pending, fulfilled, rejected)\n   - Ensures state transitions are one-way only\n   - Stores resolved value or rejection reason\n\n2. **Callback Handling**\n\n   - Supports multiple then/catch/finally callbacks\n   - Executes callbacks in order of registration\n   - Handles errors in callbacks gracefully\n\n3. **Promise Chaining**\n\n   - Supports return values from then/catch callbacks\n   - Handles nested promises automatically\n   - Maintains proper error propagation\n\n4. **Error Handling**\n   - Catches synchronous"
  },
  {
    "title": "Promise.all Implementation",
    "path": "/implementations/promise-all",
    "content": "\nPromise.all Implementation\n\nOverview\n\n`Promise.all()` takes an array of promises and returns a new promise that\nresolves when all input promises have resolved, or rejects if any promise\nrejects. This implementation includes performance monitoring and enhanced error\nhandling.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Usage with Timeout\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Handling\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Features\n\n1. **Parallel Execution**\n\n   - All promises run concurrently\n   - Maintains input order in results\n   - Optimized for parallel processing\n\n2. **Error Handling**\n\n   - Fast failure on first rejection\n   - Detailed error context\n   - Performance monitoring integration\n\n3. **Input Validation**\n\n   - Handles non-array inputs\n   - Supports mixed input types\n   - Empty array optimization\n\n4. **Resource Management**\n   - Memory-efficient result collection\n   - Proper cleanup on rejection\n   - Pe"
  },
  {
    "title": "Promise.allSettled Implementation",
    "path": "/implementations/promise-allsettled",
    "content": "\nPromise.allSettled Implementation\n\nOverview\n\n`Promise.allSettled()` returns a promise that resolves after all of the given\npromises have either fulfilled or rejected, with an array of objects that each\ndescribes the outcome of each promise. This implementation includes performance\nmonitoring and enhanced error handling.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Analysis\n\n::: code-with-tooltips\n\n\n\n:::\n\nBatch Processing\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Features\n\n1. **Complete Resolution**\n\n   - Waits for all promises to settle\n   - Collects both successes and failures\n   - Maintains promise order\n\n2. **Result Tracking**\n\n   - Detailed status for each promise\n   - Type-safe result handling\n   - Comprehensive error collection\n\n3. **Performance Monitoring**\n\n   - Individual promise tracking\n   - Batch completion metrics\n   - Resource usage monitoring\n\n4. **Error Handling**\n   - Never rejects\n   - Preserves all error"
  },
  {
    "title": "Promise.any Implementation",
    "path": "/implementations/promise-any",
    "content": "\nPromise.any Implementation\n\nOverview\n\n`Promise.any()` returns a promise that fulfills when any of the input promises\nfulfills, with the value of the fulfilled promise. If all promises are rejected,\nit rejects with an AggregateError containing all rejection reasons. This\nimplementation includes performance monitoring and enhanced error handling.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nFallback Pattern\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Aggregation\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Features\n\n1. **Success Prioritization**\n\n   - Returns first successful result\n   - Ignores rejections if any success\n   - Continues execution until success\n\n2. **Error Aggregation**\n\n   - Collects all rejection reasons\n   - AggregateError support\n   - Detailed error context\n\n3. **Performance Monitoring**\n\n   - Tracks individual promises\n   - Measures success/failure rates\n   - Resource usage monitoring\n\n4. **Resource Management**\n   - Pr"
  },
  {
    "title": "Promise.finally Implementation",
    "path": "/implementations/promise-finally",
    "content": "\nPromise.finally Implementation\n\nOverview\n\n`Promise.finally()` returns a Promise that will execute a specified function\nwhen the promise is settled (either fulfilled or rejected). This implementation\nincludes proper resource cleanup, error handling, and performance monitoring.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nResource Cleanup\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Handling\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Features\n\n1. **Guaranteed Execution**\n\n   - Runs regardless of promise state\n   - Handles both success and failure\n   - Preserves original result/error\n\n2. **Resource Management**\n\n   - Safe cleanup operations\n   - Error handling in cleanup\n   - Resource tracking\n\n3. **Chain Preservation**\n\n   - Maintains promise chain\n   - Proper error propagation\n   - Return value handling\n\n4. **Error Handling**\n   - Cleanup error management\n   - Original error preservation\n   - Error context maintenance\n\nBest Practices\n\n1."
  },
  {
    "title": "Promise.race Implementation",
    "path": "/implementations/promise-race",
    "content": "\nPromise.race Implementation\n\nOverview\n\n`Promise.race()` returns a promise that fulfills or rejects as soon as one of\nthe input promises fulfills or rejects. This implementation includes performance\nmonitoring, proper resource cleanup, and enhanced error handling.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nTimeout Pattern\n\n::: code-with-tooltips\n\n\n\n:::\n\nResource Cleanup\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Features\n\n1. **Fast Settlement**\n\n   - Returns as soon as any promise settles\n   - Handles both fulfillment and rejection\n   - Maintains promise semantics\n\n2. **Resource Management**\n\n   - Proper cleanup of losing promises\n   - Memory leak prevention\n   - Performance monitoring per promise\n\n3. **Error Handling**\n\n   - Detailed error context\n   - Stack trace preservation\n   - Error aggregation capabilities\n\n4. **Monitoring Integration**\n   - Performance tracking\n   - Resource usage monitoring\n   - Error rate tracking\n\nBes"
  },
  {
    "title": "Promise.resolve and Promise.reject Implementation",
    "path": "/implementations/promise-resolve-reject",
    "content": "\nPromise.resolve and Promise.reject Implementation\n\nOverview\n\n`Promise.resolve()` and `Promise.reject()` are static methods that create\nresolved or rejected promises respectively. This implementation includes\nperformance monitoring, proper error handling, and support for thenable objects.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nError Handling\n\n::: code-with-tooltips\n\n\n\n:::\n\nThenable Objects\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Features\n\n1. **Value Resolution**\n\n   - Immediate value wrapping\n   - Promise passthrough\n   - Thenable object support\n   - Type preservation\n\n2. **Error Handling**\n\n   - Error wrapping\n   - Type checking\n   - Context preservation\n   - Stack trace maintenance\n\n3. **Performance Monitoring**\n\n   - Resolution timing\n   - Error tracking\n   - Resource usage\n   - Chain optimization\n\n4. **Type Safety**\n   - Generic type support\n   - Thenable type checking\n   - Error type preservation\n   - Chain type infe"
  },
  {
    "title": "Modern Web Development Patterns",
    "path": "/index",
    "content": "\nWhat's Inside?\n\nThis guide provides a comprehensive collection of modern web development patterns, focusing on:\n\n- **Async JavaScript**: Master Promises, async/await, and advanced control flow\n- **TypeScript Patterns**: Learn type-safe development and utility types\n- **Modern Styling**: Explore CSS methodologies and SCSS patterns\n- **Real Examples**: Practical, production-ready code samples\n\nGetting Started\n\n1. Browse the Async Patterns section for modern async JavaScript\n2. Explore TypeScript Patterns for type-safe development\n3. Learn Modern Styling practices for maintainable CSS\n\nLatest Updates\n\n- Added comprehensive async pattern examples\n- New TypeScript utility types and patterns\n- Modern styling methodologies and best practices\n- Improved performance optimization guides\n"
  },
  {
    "title": "README",
    "path": "/node_modules/@vitejs/plugin-vue/README",
    "content": "@vitejs/plugin-vue ![npm](https://npmjs.com/package/@vitejs/plugin-vue)\n\n> Note: as of `vue` 3.2.13+ and `@vitejs/plugin-vue` 1.9.0+, `@vue/compiler-sfc` is no longer required as a peer dependency.\n\n\n\nFor JSX / TSX support, `@vitejs/plugin-vue-jsx` is also needed.\n\nOptions\n\n\n\nAsset URL handling\n\nWhen `@vitejs/plugin-vue` compiles the `<template>` blocks in SFCs, it also converts any encountered asset URLs into ESM imports.\n\nFor example, the following template snippet:\n\n\n\nIs the same as:\n\n\n\nBy default the following tag/attribute combinations are transformed, and can be configured using the `template.transformAssetUrls` option.\n\n\n\nNote that only attribute values that are static strings are transformed. Otherwise, you'd need to import the asset manually, e.g. `import imgUrl from '../image.png'`.\n\nExample for passing options to `vue/compiler-sfc`:\n\n\n\nExample for transforming custom blocks\n\n\n\nCreate a file named `Demo.vue`, add `lang=\"yaml\"` to the `<i18n>` blocks, then you can use the synt"
  },
  {
    "title": "README",
    "path": "/node_modules/unplugin-vue-macros/README",
    "content": "unplugin-vue-macros ![npm](https://npmjs.com/package/unplugin-vue-macros)\n\nPlease refer to README.md\n"
  },
  {
    "title": "README",
    "path": "/node_modules/vitepress/README",
    "content": "VitePress 📝💨\n\n![test](https://github.com/vuejs/vitepress/actions)\n![npm](https://www.npmjs.com/package/vitepress)\n![chat](https://chat.vuejs.org)\n\n---\n\nVitePress is a Vue-powered static site generator and a spiritual successor to VuePress, built on top of Vite.\n\nDocumentation\n\nTo check out docs, visit vitepress.dev.\n\nChangelog\n\nDetailed changes for each release are documented in the CHANGELOG.\n\nContribution\n\nPlease make sure to read the Contributing Guide before making a pull request.\n\nLicense\n\nMIT\n\nCopyright (c) 2019-present, Yuxi (Evan) You\n"
  },
  {
    "title": "api-examples",
    "path": "/node_modules/vitepress/template/api-examples",
    "content": "\nRuntime API Examples\n\nThis page demonstrates usage of some of the runtime APIs provided by VitePress.\n\nThe main `useData()` API can be used to access site, theme, and page data for the current page. It works in both `.md` and `.vue` files:\n\n\n\n<script setup>\nimport { useData } from 'vitepress'\n\nconst { site, theme, page, frontmatter } = useData()\n</script>\n\nResults\n\nTheme Data\n<pre>{{ theme }}</pre>\n\nPage Data\n<pre>{{ page }}</pre>\n\nPage Frontmatter\n<pre>{{ frontmatter }}</pre>\n\nMore\n\nCheck out the documentation for the full list of runtime APIs.\n"
  },
  {
    "title": "index",
    "path": "/node_modules/vitepress/template/index",
    "content": "<% if (defaultTheme) { %>---\nhttps://vitepress.dev/reference/default-theme-home-page\nlayout: home\n\nhero:\n  name: <%= title %>\n  text: <%= description %>\n  tagline: My great project tagline\n  actions:\n    - theme: brand\n      text: Markdown Examples\n      link: /markdown-examples\n    - theme: alt\n      text: API Examples\n      link: /api-examples\n\nfeatures:\n  - title: Feature A\n    details: Lorem ipsum dolor sit amet, consectetur adipiscing elit\n  - title: Feature B\n    details: Lorem ipsum dolor sit amet, consectetur adipiscing elit\n  - title: Feature C\n    details: Lorem ipsum dolor sit amet, consectetur adipiscing elit\n---\n<% } else { %>---\nhome: true\n---\n<% } %>\n"
  },
  {
    "title": "markdown-examples",
    "path": "/node_modules/vitepress/template/markdown-examples",
    "content": "Markdown Extension Examples\n\nThis page demonstrates some of the built-in markdown extensions provided by VitePress.\n\nSyntax Highlighting\n\nVitePress provides Syntax Highlighting powered by Shiki, with additional features like line-highlighting:\n\n**Input**\n\njs{4}\nexport default {\n  data () {\n    return {\n      msg: 'Highlighted!'\n    }\n  }\n}\n`\n\n**Output**\n\n\n\nCustom Containers\n\n**Input**\n\n\n\n**Output**\n\n::: info\nThis is an info box.\n:::\n\n::: tip\nThis is a tip.\n:::\n\n::: warning\nThis is a warning.\n:::\n\n::: danger\nThis is a dangerous warning.\n:::\n\n::: details\nThis is a details block.\n:::\n\nMore\n\nCheck out the documentation for the full list of markdown extensions.\n"
  },
  {
    "title": "README",
    "path": "/node_modules/vue/README",
    "content": "vue\n\nWhich dist file to use?\n\nFrom CDN or without a Bundler\n\n- **`vue(.runtime).global(.prod).js`**:\n\n  - For direct use via `<script src=\"...\">` in the browser. Exposes the `Vue` global.\n  - Note that global builds are not UMD builds. They are built as IIFEs and is only meant for direct use via `<script src=\"...\">`.\n  - In-browser template compilation:\n    - **`vue.global.js`** is the \"full\" build that includes both the compiler and the runtime so it supports compiling templates on the fly.\n    - **`vue.runtime.global.js`** contains only the runtime and requires templates to be pre-compiled during a build step.\n  - Inlines all Vue core internal packages - i.e. it's a single file with no dependencies on other files. This means you **must** import everything from this file and this file only to ensure you are getting the same instance of code.\n  - Contains hard-coded prod/dev branches, and the prod build is pre-minified. Use the `*.prod.js` files for production.\n\n- **`vue(.runtime).esm-"
  },
  {
    "title": "Bun Guide",
    "path": "/package-managers/bun",
    "content": "\nBun Guide\n\nBun is an all-in-one JavaScript runtime and package manager that focuses on performance. It provides incredibly fast package installation, a built-in bundler, test runner, and Node.js-compatible runtime.\n\nInstallation\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Commands\n\nProject Initialization\n\n::: code-with-tooltips\n\n\n\n:::\n\nPackage Installation\n\n::: code-with-tooltips\n\n\n\n:::\n\nPackage Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nScripts\n\n::: code-with-tooltips\n\n\n\n:::\n\nConfiguration\n\nBun Configuration File (`bunfig.toml`)\n\n::: code-with-tooltips\n\n\n\n:::\n\npackage.json\n\n::: code-with-tooltips\n\n\n\n:::\n\nRuntime Features\n\nHTTP Server\n\n::: code-with-tooltips\n\n\n\n:::\n\nFile Operations\n\n::: code-with-tooltips\n\n\n\n:::\n\nTesting\n\n::: code-with-tooltips\n\n\n\n:::\n\nBundler\n\nBun includes a built-in bundler:\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. **Project Setup**\n\n   - Use `bun init` for new projects\n   - Configure TypeScript properly\n   - Utilize built-in bundler\n   - Take advantage of native "
  },
  {
    "title": "Dependency Management",
    "path": "/package-managers/dependency-management",
    "content": "\nDependency Management\n\nEffective dependency management is crucial for maintaining healthy JavaScript projects. This guide covers best practices and strategies for managing project dependencies.\n\nUnderstanding Dependencies\n\nTypes of Dependencies\n\n- **dependencies**: Required for production runtime\n- **devDependencies**: Only needed for development\n- **peerDependencies**: Required by the consuming project\n- **optionalDependencies**: Optional enhancements\n- **bundledDependencies**: Bundled with the package\n\nVersion Ranges\n\n::: code-with-tooltips\n\n\n\n:::\n\nVersion Control\n\nLock Files\n\n- `package-lock.json` (npm)\n- `yarn.lock` (Yarn)\n- `pnpm-lock.yaml` (pnpm)\n- `bun.lockb` (Bun)\n\n::: code-with-tooltips\n\n\n\n:::\n\nUpdating Dependencies\n\n::: code-with-tooltips\n\n\n\n:::\n\nSecurity\n\nAuditing Dependencies\n\n::: code-with-tooltips\n\n\n\n:::\n\nVersion Pinning\n\n::: code-with-tooltips\n\n\n\n:::\n\nOptimization Strategies\n\nDependency Analysis\n\n::: code-with-tooltips\n\n\n\n:::\n\nBundle Size Optimization\n\n::: code-with-too"
  },
  {
    "title": "Package Managers Overview",
    "path": "/package-managers/index",
    "content": "\nPackage Managers Overview\n\nPackage managers are essential tools in modern web development, helping you manage project dependencies, handle version control, and maintain consistent development environments.\n\nPopular Package Managers\n\nnpm (Node Package Manager)\n\n- The default package manager for Node.js\n- Largest package registry in the world\n- Simple and widely supported\n- Workspaces support for monorepos\n\nYarn\n\n- Created by Facebook\n- Faster than npm (v1)\n- Better security features\n- Plug'n'Play for improved performance\n- Workspaces support\n\npnpm\n\n- Performance-focused package manager\n- Efficient disk space usage\n- Strict dependency management\n- Great monorepo support\n- Compatible with npm and Yarn workflows\n\nBun\n\n- All-in-one JavaScript runtime and package manager\n- Extremely fast installation speeds\n- Native bundler and transpiler\n- Compatible with npm packages\n- Built-in test runner\n\nKey Features Comparison\n\n| Feature         | npm               | Yarn      | pnpm           | Bun  "
  },
  {
    "title": "Migrating from npm to pnpm",
    "path": "/package-managers/migration/npm-to-pnpm",
    "content": "\nMigrating from npm to pnpm\n\nThis guide covers the process of migrating your project from npm to pnpm, including command mappings, configuration changes, and best practices.\n\nPrerequisites\n\n1. Install pnpm:\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Verify installation:\n\n::: code-with-tooltips\n\n\n\n:::\n\nMigration Steps\n\n1. Generate pnpm-lock.yaml\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Update CI Configuration\n\nGitHub Actions\n\n::: code-with-tooltips\n\n\n\n:::\n\n3. Update Scripts\n\npackage.json\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommand Mapping\n\nBasic Commands\n\n| npm                                | pnpm                    |\n| ---------------------------------- | ----------------------- |\n| `npm install`                      | `pnpm install`          |\n| `npm install [package]`            | `pnpm add [package]`    |\n| `npm install --save-dev [package]` | `pnpm add -D [package]` |\n| `npm uninstall [package]`          | `pnpm remove [package]` |\n| `npm run [script]`                 | `pnpm [script]`         |\n| "
  },
  {
    "title": "Migrating from npm to Yarn",
    "path": "/package-managers/migration/npm-to-yarn",
    "content": "\nMigrating from npm to Yarn\n\nThis guide covers the process of migrating your project from npm to Yarn, including command mappings, configuration changes, and best practices.\n\nPrerequisites\n\n1. Install Yarn:\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Verify installation:\n\n::: code-with-tooltips\n\n\n\n:::\n\nMigration Steps\n\n1. Generate yarn.lock\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Update CI Configuration\n\nGitHub Actions\n\n::: code-with-tooltips\n\n\n\n:::\n\n3. Update Scripts\n\npackage.json\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommand Mapping\n\nBasic Commands\n\n| npm                                | Yarn                       |\n| ---------------------------------- | -------------------------- |\n| `npm install`                      | `yarn` or `yarn install`   |\n| `npm install [package]`            | `yarn add [package]`       |\n| `npm install --save-dev [package]` | `yarn add --dev [package]` |\n| `npm uninstall [package]`          | `yarn remove [package]`    |\n| `npm run [script]`                 | `yarn [script]`"
  },
  {
    "title": "Migrating from Yarn to pnpm",
    "path": "/package-managers/migration/yarn-to-pnpm",
    "content": "\nMigrating from Yarn to pnpm\n\nThis guide covers the process of migrating your project from Yarn to pnpm, including command mappings, configuration changes, and best practices.\n\nPrerequisites\n\n1. Install pnpm:\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Verify installation:\n\n::: code-with-tooltips\n\n\n\n:::\n\nMigration Steps\n\n1. Generate pnpm-lock.yaml\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Update CI Configuration\n\nGitHub Actions\n\n::: code-with-tooltips\n\n\n\n:::\n\n3. Update Scripts\n\npackage.json\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommand Mapping\n\nBasic Commands\n\n| Yarn                     | pnpm                    |\n| ------------------------ | ----------------------- |\n| `yarn` or `yarn install` | `pnpm install`          |\n| `yarn add [package]`     | `pnpm add [package]`    |\n| `yarn add -D [package]`  | `pnpm add -D [package]` |\n| `yarn remove [package]`  | `pnpm remove [package]` |\n| `yarn [script]`          | `pnpm [script]`         |\n| `yarn test`              | `pnpm test`             |\n| `yarn build` "
  },
  {
    "title": "Monorepo Management",
    "path": "/package-managers/monorepos",
    "content": "\nMonorepo Management\n\nMonorepos allow you to manage multiple packages in a single repository. This guide covers best practices and tools for managing JavaScript monorepos effectively.\n\nWorkspace Setup\n\nnpm Workspaces\n\n::: code-with-tooltips\n\n\n\n:::\n\nYarn Workspaces\n\n::: code-with-tooltips\n\n\n\n:::\n\npnpm Workspaces\n\n::: code-with-tooltips\n\n\n\n:::\n\nProject Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\nPackage Management\n\nLocal Dependencies\n\n::: code-with-tooltips\n\n\n\n:::\n\nInstallation Commands\n\n::: code-with-tooltips\n\n\n\n:::\n\nScript Execution\n\nRunning Scripts\n\n::: code-with-tooltips\n\n\n\n:::\n\nParallel Execution\n\n::: code-with-tooltips\n\n\n\n:::\n\nVersion Management\n\nIndependent Versions\n\n::: code-with-tooltips\n\n\n\n:::\n\nFixed Versions\n\n::: code-with-tooltips\n\n\n\n:::\n\nBuild Systems\n\nTurborepo\n\n::: code-with-tooltips\n\n\n\n:::\n\nNx\n\n::: code-with-tooltips\n\n\n\n:::\n\nDependencies Management\n\nShared Dependencies\n\n::: code-with-tooltips\n\n\n\n:::\n\nDependency Hoisting\n\n::: code-with-tooltips\n\n\n\n:::\n\nDevelopment Workflow\n\n"
  },
  {
    "title": "npm Guide",
    "path": "/package-managers/npm",
    "content": "\nnpm Guide\n\nnpm (Node Package Manager) is the default package manager for Node.js and the world's largest software registry. It's installed automatically with Node.js and provides a robust foundation for managing JavaScript packages.\n\nInstallation\n\nnpm comes bundled with Node.js:\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Commands\n\nProject Initialization\n\n::: code-with-tooltips\n\n\n\n:::\n\nPackage Installation\n\n::: code-with-tooltips\n\n\n\n:::\n\nPackage Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nScripts\n\n::: code-with-tooltips\n\n\n\n:::\n\nConfiguration\n\nnpm Configuration File (`.npmrc`)\n\n::: code-with-tooltips\n\n\n\n:::\n\npackage.json\n\n::: code-with-tooltips\n\n\n\n:::\n\nWorkspaces\n\nnpm supports workspaces for monorepo management:\n\n::: code-with-tooltips\n\n\n\n:::\n\nWorkspace Commands\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. **Version Control**\n\n   - Always commit `package.json` and `package-lock.json`\n   - Use `.npmignore` to exclude unnecessary files\n   - Use `save-exact` for critical dependencies\n\n2. **S"
  },
  {
    "title": "pnpm Guide",
    "path": "/package-managers/pnpm",
    "content": "\npnpm Guide\n\npnpm is a fast, disk space efficient package manager that creates a non-flat node_modules directory. It uses hard links and symlinks to save disk space and boost installation speed.\n\nInstallation\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Commands\n\nProject Initialization\n\n::: code-with-tooltips\n\n\n\n:::\n\nPackage Installation\n\n::: code-with-tooltips\n\n\n\n:::\n\nPackage Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nScripts\n\n::: code-with-tooltips\n\n\n\n:::\n\nConfiguration\n\npnpm Configuration File (`.npmrc`)\n\n::: code-with-tooltips\n\n\n\n:::\n\npackage.json\n\n::: code-with-tooltips\n\n\n\n:::\n\nWorkspaces\n\npnpm has excellent monorepo support through workspaces:\n\n::: code-with-tooltips\n\n\n\n:::\n\nWorkspace Commands\n\n::: code-with-tooltips\n\n\n\n:::\n\nStore & Linking\n\npnpm uses a unique approach to manage dependencies:\n\nContent-addressable Store\n\n::: code-with-tooltips\n\n\n\n:::\n\nHard Links\n\n- Each version of a package is saved only once on disk\n- Multiple projects share the same package versions\n- Significant disk sp"
  },
  {
    "title": "Package Manager Security",
    "path": "/package-managers/security",
    "content": "\nPackage Manager Security\n\nSecurity is crucial when working with package managers. This guide covers best practices, common vulnerabilities, and strategies to maintain a secure dependency tree.\n\nSecurity Auditing\n\nRunning Security Audits\n\n::: code-with-tooltips\n\n\n\n:::\n\nAudit Configuration\n\n::: code-with-tooltips\n\n\n\n:::\n\nSupply Chain Security\n\nRegistry Security\n\n::: code-with-tooltips\n\n\n\n:::\n\nPackage Signing\n\n::: code-with-tooltips\n\n\n\n:::\n\nTrusted Publishers\n\n::: code-with-tooltips\n\n\n\n:::\n\nDependency Management\n\nVersion Pinning\n\n::: code-with-tooltips\n\n\n\n:::\n\nLock File Security\n\n::: code-with-tooltips\n\n\n\n:::\n\nAuthentication & Authorization\n\nRegistry Authentication\n\n::: code-with-tooltips\n\n\n\n:::\n\nAccess Control\n\n::: code-with-tooltips\n\n\n\n:::\n\nCI/CD Security\n\nEnvironment Variables\n\n::: code-with-tooltips\n\n\n\n:::\n\nSecurity Checks\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Dependency Management\n\n- Regularly update dependencies\n- Use exact versions for critical packages\n- Implement se"
  },
  {
    "title": "Version Control",
    "path": "/package-managers/version-control",
    "content": "\nVersion Control\n\nProper version control practices for package managers are essential for maintaining consistent and reproducible builds across team members and deployment environments.\n\nLock Files\n\nPurpose and Importance\n\nLock files ensure dependency tree consistency across different environments by:\n\n- Pinning exact versions\n- Recording dependency tree structure\n- Storing integrity checksums\n- Tracking resolution details\n\nLock Files by Package Manager\n\n::: code-with-tooltips\n\n\n\n:::\n\nGit Configuration\n\n.gitignore\n\n::: code-with-tooltips\n\n\n\n:::\n\nWhat to Commit\n\n::: code-with-tooltips\n\n\n\n:::\n\nVersion Control Strategies\n\nSemantic Versioning\n\n::: code-with-tooltips\n\n\n\n:::\n\nVersion Constraints\n\n::: code-with-tooltips\n\n\n\n:::\n\nMonorepo Strategies\n\nWorkspace Configuration\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nVersion Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nCI/CD Integration\n\nCache Configuration\n\nGitHub Actions\n\n::: code-with-tooltips\n\n\n\n:::\n\nGitLab CI\n\n::: code-wit"
  },
  {
    "title": "Yarn Guide",
    "path": "/package-managers/yarn",
    "content": "\nYarn Guide\n\nYarn is a fast, reliable, and secure package manager developed by Facebook. It offers improved performance, better dependency resolution, and enhanced security features compared to npm.\n\nInstallation\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Commands\n\nProject Initialization\n\n::: code-with-tooltips\n\n\n\n:::\n\nPackage Installation\n\n::: code-with-tooltips\n\n\n\n:::\n\nPackage Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nScripts\n\n::: code-with-tooltips\n\n\n\n:::\n\nConfiguration\n\nYarn Configuration File (`.yarnrc.yml`)\n\n::: code-with-tooltips\n\n\n\n:::\n\npackage.json\n\n::: code-with-tooltips\n\n\n\n:::\n\nWorkspaces\n\nYarn has excellent support for monorepos through workspaces:\n\n::: code-with-tooltips\n\n\n\n:::\n\nWorkspace Commands\n\n::: code-with-tooltips\n\n\n\n:::\n\nPlug'n'Play (PnP)\n\nYarn's PnP feature improves installation and resolution speed:\n\n::: code-with-tooltips\n\n\n\n:::\n\nPnP Benefits\n\n- Faster installation\n- Guaranteed dependency resolution\n- Better security\n- Reduced disk usage\n- Zero-Installs capability\n\nBe"
  },
  {
    "title": "Parallel Task Execution Patterns",
    "path": "/patterns/tasks-parallel",
    "content": "\nParallel Task Execution Patterns\n\nOverview\n\nRunning async tasks in parallel means executing multiple tasks simultaneously without waiting for each other. This pattern is useful when tasks are independent and you want to maximize throughput.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Concepts\n\n1. **Concurrent Execution**: Tasks run simultaneously\n2. **Concurrency Control**: Optional limit on parallel tasks\n3. **Progress Tracking**: Monitor completion status\n4. **Resource Management**: Control system load\n\nEdge Cases\n\n- Empty task array\n- Task throws error\n- Concurrency limit exceeded\n- Memory constraints\n- System resource limits\n\nCommon Pitfalls\n\n1. **Resource Exhaustion**: Too many concurrent tasks\n2. **Memory Leaks**: Not cleaning up resources\n3. **Error Handling**: Lost error contexts\n4. **Race Conditions**: Unmanaged shared resources\n\nBest Practices\n\n1. Set appropriate concurrency limits\n2. Monitor system resources\n3. Implement"
  },
  {
    "title": "Racing Task Patterns",
    "path": "/patterns/tasks-race",
    "content": "\nRacing Task Patterns\n\nOverview\n\nRunning async tasks in race means executing multiple tasks simultaneously and taking the result of the first task that completes successfully. This pattern is useful when you have multiple ways to accomplish the same goal and want the fastest result.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Concepts\n\n1. **First Success Wins**: Takes result of first successful completion\n2. **Error Handling**: Continues on individual failures\n3. **Timeout Support**: Optional time limit for race\n4. **Progress Tracking**: Optional callbacks for task completion\n\nEdge Cases\n\n- Empty task array\n- All tasks fail\n- Timeout occurs\n- Tasks complete simultaneously\n- Resource cleanup for losing tasks\n\nCommon Pitfalls\n\n1. **Resource Leaks**: Not cancelling losing tasks\n2. **Error Handling**: Not handling individual task failures\n3. **Timeout Management**: Not cleaning up after timeout\n4. **Memory Management**: Not limiting con"
  },
  {
    "title": "Sequential Task Execution Patterns",
    "path": "/patterns/tasks-series",
    "content": "\nSequential Task Execution Patterns\n\nOverview\n\nRunning async tasks in series means executing them one after another, where each\ntask waits for the previous task to complete before starting. This pattern is\nuseful when tasks depend on each other or need to be executed in a specific\norder.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Concepts\n\n1. **Sequential Execution**: Tasks run one after another\n2. **Input/Output Chaining**: Each task can use previous task's output\n3. **Error Propagation**: Series stops on first error\n4. **Type Safety**: Maintains types between tasks\n\nEdge Cases\n\n- Empty task array\n- Task throws error\n- Task never resolves\n- Invalid input type\n- Memory leaks in long series\n\nCommon Pitfalls\n\n1. **Error Handling**: Not properly catching task errors\n2. **Memory Management**: Accumulating results for long series\n3. **Type Mismatches**: Incorrect input/output types\n4. **Infinite Series**: Tasks that never complete\n\nBest"
  },
  {
    "title": "Button Components",
    "path": "/react-component-patterns/form/button",
    "content": "\nButton Components\n\nOverview\n\nA comprehensive set of button components that provide consistent styling and behavior across your application. These components are fully accessible, support keyboard navigation, and include loading states.\n\nComponents\n\nBase Button\n\nThe foundation button component with multiple variants:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Buttons\n\n::: code-with-tooltips\n\n\n\n:::\n\nButton Sizes\n\n::: code-with-tooltips\n\n\n\n:::\n\nWith Icons\n\n::: code-with-tooltips\n\n\n\n:::\n\nStates\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Accessibility\n\n- Use proper ARIA attributes\n- Support keyboard navigation\n- Maintain focus states\n- Provide loading state indicators\n\n2. User Experience\n\n- Use appropriate cursor styles\n- Implement hover and active states\n- Provide visual feedback\n- Maintain consistent spacing\n\n3. Performance\n\n- Optimize icon loading\n- Use CSS transitions\n- Implement proper memoization\n- Handle click events efficiently\n\n4. "
  },
  {
    "title": "Checkbox Components",
    "path": "/react-component-patterns/form/checkbox",
    "content": "\nCheckbox Components\n\nOverview\n\nA comprehensive set of checkbox components that handle various selection scenarios, including indeterminate states and grouping. These components are built with TypeScript and follow WAI-ARIA practices.\n\nComponents\n\nBase Checkbox\n\nThe foundation checkbox component with support for indeterminate state:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nCheckbox Group\n\nA component for managing multiple related checkboxes:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Checkbox\n\n::: code-with-tooltips\n\n\n\n:::\n\nRequired Checkbox with Error\n\n::: code-with-tooltips\n\n\n\n:::\n\nCheckbox Sizes\n\n::: code-with-tooltips\n\n\n\n:::\n\nIndeterminate State\n\n::: code-with-tooltips\n\n\n\n:::\n\nCheckbox Group Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nNested Checkboxes\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Accessibility\n\n- Use proper ARIA attributes\n- Support keyboard navigation\n- Provide clear l"
  },
  {
    "title": "Input Components",
    "path": "/react-component-patterns/form/input",
    "content": "\nInput Components\n\nOverview\n\nA comprehensive set of input components that handle various text input scenarios, form validation, and accessibility requirements. These components are built with TypeScript and follow modern React patterns.\n\nComponents\n\nBase Input\n\nThe foundation input component with validation and state management:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nPassword Input\n\nA specialized input component for password fields with show/hide functionality:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Input\n\n::: code-with-tooltips\n\n\n\n:::\n\nRequired Input with Validation\n\n::: code-with-tooltips\n\n\n\n:::\n\nInput with Icons\n\n::: code-with-tooltips\n\n\n\n:::\n\nInput Sizes\n\n::: code-with-tooltips\n\n\n\n:::\n\nInput States\n\n::: code-with-tooltips\n\n\n\n:::\n\nPassword Input\n\n::: code-with-tooltips\n\n\n\n:::\n\nForm Integration Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Accessibility\n\n- Use proper ARIA attributes\n- Provide clear err"
  },
  {
    "title": "Radio Components",
    "path": "/react-component-patterns/form/radio",
    "content": "\nRadio Components\n\nOverview\n\nOur radio components provide accessible and customizable radio button controls. They support grouping, custom styles, and keyboard navigation.\n\nComponents\n\nRadio Group\n\nThe container component for managing radio button state:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nRadio\n\nThe individual radio button component:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Radio Group\n\n::: code-with-tooltips\n\n\n\n:::\n\nWith Descriptions\n\n::: code-with-tooltips\n\n\n\n:::\n\nDisabled State\n\n::: code-with-tooltips\n\n\n\n:::\n\nWith Error\n\n::: code-with-tooltips\n\n\n\n:::\n\nHorizontal Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Accessibility\n\n- Use proper ARIA attributes\n- Support keyboard navigation\n- Maintain focus states\n- Provide clear labels\n- Handle screen readers\n\n2. UX Guidelines\n\n- Clear visual feedback\n- Sufficient touch targets\n- Logical grouping\n- Descriptive labels\n- Error handling\n\n3. Performance\n\n- Minimiz"
  },
  {
    "title": "Select Components",
    "path": "/react-component-patterns/form/select",
    "content": "\nSelect Components\n\nOverview\n\nA comprehensive set of select components that handle both single and multiple selection scenarios. These components are built with TypeScript, support keyboard navigation, and follow WAI-ARIA practices.\n\nComponents\n\nBase Select\n\nThe foundation select component with support for single selection:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nMultiSelect Component\n\nA select component that supports multiple selection:\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Select\n\n::: code-with-tooltips\n\n\n\n:::\n\nRequired Select with Validation\n\n::: code-with-tooltips\n\n\n\n:::\n\nSelect with Icon\n\n::: code-with-tooltips\n\n\n\n:::\n\nSelect Sizes\n\n::: code-with-tooltips\n\n\n\n:::\n\nMultiSelect Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nDisabled Options\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Accessibility\n\n- Use proper ARIA attributes\n- Support keyboard navigation\n- Provide clear labels\n- Handle focus management\n- Announce selection changes\n\n2. User Exp"
  },
  {
    "title": "Switch Components",
    "path": "/react-component-patterns/form/switch",
    "content": "\nSwitch Components\n\nOverview\n\nOur switch components provide an intuitive way to toggle between two states. They feature smooth animations, accessible controls, and customizable styles.\n\nComponents\n\nSwitch\n\nThe base switch component with toggle functionality:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Switch\n\n::: code-with-tooltips\n\n\n\n:::\n\nWith Description\n\n::: code-with-tooltips\n\n\n\n:::\n\nDifferent Sizes\n\n::: code-with-tooltips\n\n\n\n:::\n\nColor Variants\n\n::: code-with-tooltips\n\n\n\n:::\n\nDisabled State\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Accessibility\n\n- Use proper ARIA attributes\n- Support keyboard navigation\n- Maintain focus states\n- Provide clear labels\n- Handle screen readers\n\n2. UX Guidelines\n\n- Clear visual feedback\n- Smooth animations\n- Instant response\n- Logical grouping\n- Error handling\n\n3. Performance\n\n- Optimize animations\n- Minimize re-renders\n- Use efficient selectors\n- Cache calculations\n- Handle transitions\n\n4. Implementat"
  },
  {
    "title": "Color System",
    "path": "/react-component-patterns/foundation/colors",
    "content": "\nColor System\n\nOverview\n\nOur color system provides a consistent and accessible palette for React components. It supports both light and dark themes, maintains WCAG compliance, and integrates seamlessly with our component library.\n\nColor Tokens\n\nBrand Colors\n\n::: code-with-tooltips\n\n\n\n:::\n\nSemantic Colors\n\n::: code-with-tooltips\n\n\n\n:::\n\nColor Utilities\n\nColor Provider\n\nA context provider for managing theme colors:\n\n::: code-with-tooltips\n\n\n\n:::\n\nColor Hook\n\nA custom hook for accessing theme colors:\n\n::: code-with-tooltips\n\n\n\n:::\n\nColor Components\n\nColor Swatch\n\nA component for displaying color samples:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nTheme Integration\n\n::: code-with-tooltips\n\n\n\n:::\n\nColor Palette Display\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Accessibility\n\n- Maintain WCAG 2.1 AA contrast ratios\n- Provide sufficient color contrast\n- Don't rely on color alone\n- Support color blindness\n- Test with sc"
  },
  {
    "title": "Icon System",
    "path": "/react-component-patterns/foundation/icons",
    "content": "\nIcon System\n\nOverview\n\nOur icon system provides a flexible and accessible way to use SVG icons in React components. It supports customization, themes, and follows accessibility best practices.\n\nComponents\n\nBase Icon\n\nThe foundation icon component with customization options:\n\n::: code-with-tooltips\n\n\n\n:::\n\nIcon Components\n\nCommon icon components built on the base Icon:\n\n::: code-with-tooltips\n\n\n\n:::\n\nIcon Button\n\nA button component with icon support:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Icons\n\n::: code-with-tooltips\n\n\n\n:::\n\nIcon Buttons\n\n::: code-with-tooltips\n\n\n\n:::\n\nLoading State\n\n::: code-with-tooltips\n\n\n\n:::\n\nIcon Sizes\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Accessibility\n\n- Provide labels for non-decorative icons\n- Use proper ARIA attributes\n- Support keyboard navigation\n- Maintain focus states\n- Consider color contrast\n\n2. Performance\n\n- Optimize SVG paths\n- Use proper caching\n- Implement lazy loading\n- Bundle icons effi"
  },
  {
    "title": "Semantic HTML Guide",
    "path": "/react-component-patterns/foundation/semantic-html",
    "content": "\nSemantic HTML Guide\n\nOverview\n\nThis guide provides best practices for using semantic HTML elements in React components. Following these guidelines improves accessibility, SEO, and code maintainability.\n\nDocument Structure Elements\n\n`<main>`\n\nUse for the primary content of the document. Should be unique per page.\n\n::: code-with-tooltips\n\n\n\n:::\n\n`<article>`\n\nUse for self-contained, independently distributable content.\n\n::: code-with-tooltips\n\n\n\n:::\n\n`<section>`\n\nUse for thematically grouped content, typically with a heading.\n\n::: code-with-tooltips\n\n\n\n:::\n\n`<aside>`\n\nUse for content tangentially related to the main content.\n\n::: code-with-tooltips\n\n\n\n:::\n\nNavigation Elements\n\n`<nav>`\n\nUse for major navigation blocks.\n\n::: code-with-tooltips\n\n\n\n:::\n\n`<header>`\n\nUse for introductory content or navigation aids.\n\n::: code-with-tooltips\n\n\n\n:::\n\n`<footer>`\n\nUse for footer content of a section or page.\n\n::: code-with-tooltips\n\n\n\n:::\n\nContent Elements\n\n`<div>` vs Semantic Elements\n\nUse `div` on"
  },
  {
    "title": "Spacing System",
    "path": "/react-component-patterns/foundation/spacing",
    "content": "\nSpacing System\n\nOverview\n\nOur spacing system provides a consistent and scalable approach to component layout and spacing. It uses a base unit scale that maintains visual harmony across the application.\n\nSpacing Scale\n\nBase Units\n\n::: code-with-tooltips\n\n\n\n:::\n\nSemantic Spacing\n\n::: code-with-tooltips\n\n\n\n:::\n\nSpacing Components\n\nStack\n\nA component for managing vertical spacing:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nCluster\n\nA component for managing horizontal spacing:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nStack Component\n\n::: code-with-tooltips\n\n\n\n:::\n\nCluster Component\n\n::: code-with-tooltips\n\n\n\n:::\n\nNested Spacing\n\n::: code-with-tooltips\n\n\n\n:::\n\nSpacing Utilities\n\nMargin and Padding Classes\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Consistency\n\n- Use the spacing scale consistently\n- Avoid magic numbers\n- Follow spacing patterns\n- Maintain rhythm\n- Use semantic values\n\n2. Responsive Design\n\n- Use relative units"
  },
  {
    "title": "Typography Components",
    "path": "/react-component-patterns/foundation/typography",
    "content": "\nTypography Components\n\nOverview\n\nA comprehensive set of typography components that provide consistent text styling across your application. These components follow modern design principles and are fully accessible.\n\nComponents\n\nText Component\n\nA flexible text component that handles different variants and styles:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nHeading Component\n\nA component for rendering consistent headings:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Text Styles\n\n::: code-with-tooltips\n\n\n\n:::\n\nArticle Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Accessibility\n\n- Use semantic heading levels (h1-h6)\n- Maintain proper heading hierarchy\n- Ensure sufficient color contrast\n- Support user font size preferences\n\n2. Responsive Design\n\n- Use relative units (rem/em)\n- Implement fluid typography\n- Test at different viewport sizes\n- Consider line length limits\n\n3. Performance\n\n- Implement proper font loading\n- Us"
  },
  {
    "title": "React Component Patterns",
    "path": "/react-component-patterns/index",
    "content": "\nReact Component Patterns\n\nOverview\n\nA comprehensive guide to building modern, maintainable React components using best practices, design patterns, and TypeScript. This guide focuses on creating a robust component library that follows DRY principles, composable design, and performance optimization.\n\nQuick Start\n\nBasic Component Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nComponent Categories\n\nOur React component library is organized into the following categories:\n\nFoundation\n\n- Typography - Text components and styles\n- Colors - Color system and themes\n- Spacing - Layout and spacing system\n- Icons - Icon system and usage\n\nLayout\n\n- Container - Content wrapper components\n- Grid - Grid system components\n- Stack - Vertical/horizontal stacking\n- Flex - Flexbox components\n\nForm Controls\n\n- Button - Button variants and states\n- Input - Text input components\n- Select - Dropdown selection\n- Checkbox - Checkbox components\n- Radio - Radio button groups\n- Switch - Togg"
  },
  {
    "title": "Container Components",
    "path": "/react-component-patterns/layout/container",
    "content": "\nContainer Components\n\nOverview\n\nOur container components provide consistent and responsive layout patterns for content organization. They support various sizes, paddings, and responsive behaviors.\n\nComponents\n\nBase Container\n\nThe foundation container component for content width management:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nSection Container\n\nA container component for page sections with vertical spacing:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nContent Container\n\nA container component optimized for text content:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Container\n\n::: code-with-tooltips\n\n\n\n:::\n\nFluid Container\n\n::: code-with-tooltips\n\n\n\n:::\n\nSection with Container\n\n::: code-with-tooltips\n\n\n\n:::\n\nContent Container\n\n::: code-with-tooltips\n\n\n\n:::\n\nNested Containers\n\n::: code-with-tooltips\n\n\n\n:::\n\nResponsive Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\nSemantic HTML Usage\n\n::: code-with-tooltips\n\n\n\n:::\n"
  },
  {
    "title": "Flex Components",
    "path": "/react-component-patterns/layout/flex",
    "content": "\nFlex Components\n\nOverview\n\nOur flex components provide an intuitive way to create flexible layouts using CSS Flexbox. They support various alignment, distribution, and responsive behaviors.\n\nComponents\n\nBase Flex\n\nThe foundation flex component with comprehensive options:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nFlex Item\n\nA component for flex items with grow, shrink, and basis properties:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nSpacer\n\nA utility component for creating flexible space:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Flex\n\n::: code-with-tooltips\n\n\n\n:::\n\nCentered Content\n\n::: code-with-tooltips\n\n\n\n:::\n\nNavigation Bar\n\n::: code-with-tooltips\n\n\n\n:::\n\nCard Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\nComplex Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Layout Patterns\n\n- Use appropriate direction\n- Consider content flow\n- Handle wrapping\n- Maintain spacing\n- Use semantic markup\n\n2. Respo"
  },
  {
    "title": "Grid Components",
    "path": "/react-component-patterns/layout/grid",
    "content": "\nGrid Components\n\nOverview\n\nOur grid system provides a flexible and responsive way to create complex layouts. It supports both CSS Grid and Flexbox with various configuration options.\n\nComponents\n\nBase Grid\n\nThe foundation grid component with responsive columns:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nGrid Item\n\nA component for grid items with span and positioning:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nAuto Grid\n\nA component for auto-responsive grid layouts:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Grid\n\n::: code-with-tooltips\n\n\n\n:::\n\nResponsive Grid\n\n::: code-with-tooltips\n\n\n\n:::\n\nComplex Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\nAuto Grid\n\n::: code-with-tooltips\n\n\n\n:::\n\nGrid with Explicit Positioning\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Responsive Design\n\n- Use responsive columns\n- Consider breakpoints\n- Handle edge cases\n- Maintain spacing\n- Support mobile views\n\n2. Performance\n\n- "
  },
  {
    "title": "Breadcrumb Components",
    "path": "/react-component-patterns/navigation/breadcrumb",
    "content": "\nBreadcrumb Components\n\nOverview\n\nOur breadcrumb components provide a clear navigation trail for users to understand their location within the application hierarchy.\n\nComponents\n\nBreadcrumb Container\n\nThe container component for breadcrumb items:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nBreadcrumb Item\n\nThe individual breadcrumb item component:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Breadcrumb\n\n::: code-with-tooltips\n\n\n\n:::\n\nCustom Separator\n\n::: code-with-tooltips\n\n\n\n:::\n\nWith Icons\n\n::: code-with-tooltips\n\n\n\n:::\n\nCollapsed Items\n\n::: code-with-tooltips\n\n\n\n:::\n\nWith Dropdown\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Accessibility\n\n- Use proper ARIA labels\n- Support keyboard navigation\n- Maintain focus states\n- Clear visual hierarchy\n- Screen reader support\n\n2. UX Guidelines\n\n- Clear visual separation\n- Consistent spacing\n- Logical hierarchy\n- Responsive behavior\n- Touch targets\n\n3. Performance\n\n- Minimize re-"
  },
  {
    "title": "Tab Components",
    "path": "/react-component-patterns/navigation/tabs",
    "content": "\nTab Components\n\nOverview\n\nOur tab components provide an intuitive way to organize and navigate between related sections of content. They support keyboard navigation, animations, and various styling options.\n\nComponents\n\nTab Container\n\nThe main container component for managing tab state:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nTab List\n\nThe container for tab triggers:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nTab Trigger\n\nThe clickable tab button:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nTab Panel\n\nThe content container for each tab:\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Examples\n\nBasic Tabs\n\n::: code-with-tooltips\n\n\n\n:::\n\nDifferent Variants\n\n::: code-with-tooltips\n\n\n\n:::\n\nWith Icons\n\n::: code-with-tooltips\n\n\n\n:::\n\nDisabled Tabs\n\n::: code-with-tooltips\n\n\n\n:::\n\nStretched Tabs\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Accessibility\n\n- Use proper ARIA roles\n- Support keyboard navigati"
  },
  {
    "title": "BEM Methodology Guide",
    "path": "/styling/bem-methodology",
    "content": "\nBEM Methodology\n\nOverview\n\nBEM (Block Element Modifier) is a naming convention methodology that helps create reusable components and code sharing in front-end development.\n\nCore Concepts\n\nBlock\n\nA standalone entity that is meaningful on its own.\n\n::: code-with-tooltips\n\n\n\n:::\n\nElement\n\nA part of a block that has no standalone meaning and is semantically tied to its block.\n\n::: code-with-tooltips\n\n\n\n:::\n\nModifier\n\nA flag on a block or element that changes appearance or behavior.\n\n::: code-with-tooltips\n\n\n\n:::\n\nImplementation Examples\n\nBasic Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nComplex Component\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Naming Conventions\n\n- Use lowercase letters\n- Words within names are separated by hyphens (-)\n- Elements are separated from blocks by two underscores (\\_\\_)\n- Modifiers are separated from blocks or elements by two hyphens (--)\n\n2. Structure\n\n- Keep nesting levels to a minimum\n- A"
  },
  {
    "title": "CSS Patterns Guide",
    "path": "/styling/css-patterns",
    "content": "\nCSS Patterns\n\nOverview\n\nModern CSS patterns and best practices for building maintainable and performant web applications.\n\nModern CSS Features\n\nCustom Properties (Variables)\n\n::: code-with-tooltips\n\n\n\n:::\n\nContainer Queries\n\n::: code-with-tooltips\n\n\n\n:::\n\nGrid Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\nFlexbox Patterns\n\n::: code-with-tooltips\n\n\n\n:::\n\nLayout Patterns\n\nHoly Grail Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\nCard Grid\n\n::: code-with-tooltips\n\n\n\n:::\n\nComponent Patterns\n\nButton System\n\n::: code-with-tooltips\n\n\n\n:::\n\nForm Controls\n\n::: code-with-tooltips\n\n\n\n:::\n\nResponsive Patterns\n\nFluid Typography\n\n::: code-with-tooltips\n\n\n\n:::\n\nResponsive Images\n\n::: code-with-tooltips\n\n\n\n:::\n\nPerformance Patterns\n\nContent Visibility\n\n::: code-with-tooltips\n\n\n\n:::\n\nWill-Change\n\n::: code-with-tooltips\n\n\n\n:::\n\nAnimation Patterns\n\nKeyframe Animations\n\n::: code-with-tooltips\n\n\n\n:::\n\nTransitions\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Use Logical Properties\n\n::: code-with-tooltips\n\n\n\n:::\n\n2."
  },
  {
    "title": "HTML Patterns Guide",
    "path": "/styling/html-patterns",
    "content": "\nHTML Layout Patterns\n\nOverview\n\nModern HTML layout patterns focusing on semantic structure, accessibility, and best practices for building inclusive web applications.\n\nSemantic Structure\n\nBasic Page Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\nAccessibility Patterns\n\nForm Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\nNavigation Patterns\n\n::: code-with-tooltips\n\n\n\n:::\n\nContent Patterns\n\nArticle Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\nCard Components\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Document Structure\n\n- Use semantic HTML5 elements (`<header>`, `<nav>`, `<main>`, `<article>`, etc.)\n- Maintain proper heading hierarchy (h1-h6)\n- Include skip links for keyboard navigation\n- Use appropriate ARIA landmarks and roles\n\n2. Forms and Inputs\n\n- Associate labels with form controls\n- Group related fields with `<fieldset>` and `<legend>`\n- Provide clear error messages and validation\n- Use appropriate input types and attributes\n- Include helper text and instructions\n\n3. Images and Media\n\n- Alw"
  },
  {
    "title": "Modern CSS & SCSS Patterns",
    "path": "/styling/index",
    "content": "\nModern CSS & SCSS Patterns\n\nLearn modern CSS methodologies and SCSS patterns for scalable applications.\n\nCore Concepts\n\n- **CSS Architecture**: Scalable and maintainable CSS patterns\n- **SCSS Features**: Leveraging preprocessor capabilities\n- **Methodologies**: BEM and other naming conventions\n- **Responsive Design**: Mobile-first approach\n\nAvailable Guides\n\nCSS Fundamentals\n\n- CSS Patterns - Modern CSS patterns and best practices\n- SCSS Patterns - Advanced SCSS techniques\n- HTML Patterns - Semantic HTML and accessibility\n\nMethodologies\n\n- BEM Methodology - Block Element Modifier pattern\n- Single Direction Spacing - Consistent spacing\n- Lobotomized Owl - Advanced CSS selectors\n\nQuick Examples\n\nModern CSS Features\n\n::: code-with-tooltips\n\n\n\n:::\n\nSCSS Mixins\n\n::: code-with-tooltips\n\n\n\n:::\n\nBEM Pattern\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. **CSS Architecture**\n\n   - Use CSS custom properties for theming\n   - Implement consistent spacing system\n   - Follow single responsibili"
  },
  {
    "title": "lobotomized-owl",
    "path": "/styling/lobotomized-owl",
    "content": "The Lobotomized Owl Selector\n\nOverview\n\nThe Lobotomized Owl Selector (`* + *`) is a powerful CSS technique for managing vertical rhythm and spacing between elements, introduced by Heydon Pickering.\n\nCore Concept\n\nThe selector consists of a universal selector (`*`) followed by an adjacent sibling combinator (`+`) and another universal selector (`*`), targeting any element that follows another element.\n\n::: code-with-tooltips\n\n\n\n:::\n\nImplementation Examples\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Examples\n\nArticle Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nForm Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nResponsive Spacing\n\n::: code-with-tooltips\n\n\n\n:::\n\nComponent-Specific Spacing\n\n::: code-with-tooltips\n\n\n\n:::\n\nException Handling\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Scope Appropriately\n\n- Apply the owl selector to specific containers rather than globally\n- Use class-scoped selectors to "
  },
  {
    "title": "SCSS Patterns Guide",
    "path": "/styling/scss-patterns",
    "content": "\nSCSS Patterns\n\nOverview\n\nThis guide covers modern SCSS patterns and best practices for maintainable and scalable stylesheets.\n\nModern SCSS Features\n\nModule System\n\n::: code-with-tooltips\n\n\n\n:::\n\nVariables and Maps\n\n::: code-with-tooltips\n\n\n\n:::\n\nColor Functions\n\n::: code-with-tooltips\n\n\n\n:::\n\nMixins and Functions\n\n::: code-with-tooltips\n\n\n\n:::\n\nArchitecture Patterns\n\n7-1 Pattern\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Use Modern Module System\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Namespace Variables\n\n::: code-with-tooltips\n\n\n\n:::\n\n3. BEM Naming Convention\n\n::: code-with-tooltips\n\n\n\n:::\n\n4. Mobile-First Approach\n\n::: code-with-tooltips\n\n\n\n:::\n\n5. CSS Custom Properties Integration\n\n::: code-with-tooltips\n\n\n\n:::\n\n6. Performance Considerations\n\n::: code-with-tooltips\n\n\n\n:::\n\nTools and Linting\n\nStylelint Configuration\n\n::: code-with-tooltips\n\n\n\n:::\n\nReferences\n\n- Sass Documentation\n- Sass Guidelines\n- Modern CSS with Sass\n"
  },
  {
    "title": "single-direction-spacing",
    "path": "/styling/single-direction-spacing",
    "content": "Single-Direction Spacing\n\nOverview\n\nSingle-Direction Spacing (also known as Unidirectional Margin) is a CSS layout pattern that establishes a consistent spacing approach by applying margins in only one direction.\n\nCore Concepts\n\nThe Rule\n\n- Apply margins in one direction only (typically bottom or right)\n- Use padding for internal spacing\n- Maintain a single source of truth for spacing values\n- Prevent margin collapsing issues\n\nImplementation Examples\n\nBasic Usage\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Examples\n\nArticle Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nForm Layout\n\n::: code-with-tooltips\n\n\n\n:::\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nResponsive Spacing\n\n::: code-with-tooltips\n\n\n\n:::\n\nGrid Systems\n\n::: code-with-tooltips\n\n\n\n:::\n\nComponent Spacing\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Consistent Direction\n\n- Choose either bottom or right margins (bottom for vertical, right for horizontal)\n- Stick to the chosen direction thro"
  },
  {
    "title": "Deep Dive - Testing Strategy",
    "path": "/tests/deep-dive-testing-strategy",
    "content": "\nDeep Dive: Testing Strategy\n\nThis guide explores testing strategies in depth, covering various testing methodologies and how to implement them effectively in your projects.\n\nTesting Pyramid\n\nThe testing pyramid is a concept that helps visualize the different types of tests and their relative quantities in a well-balanced testing strategy:\n\n1. **Unit Tests** (Base)\n\n   - Fast and focused\n   - Test individual components in isolation\n   - Should make up the majority of your tests\n\n2. **Integration Tests** (Middle)\n\n   - Test how components work together\n   - More complex setup than unit tests\n   - Fewer in number than unit tests\n\n3. **End-to-End Tests** (Top)\n   - Test complete user flows\n   - Most complex setup\n   - Fewest in number\n\nTest Types\n\nUnit Tests\n\n- Test individual functions, methods, or components\n- Should be isolated from external dependencies\n- Fast and reliable\n- Easy to maintain\n\nIntegration Tests\n\n- Test interactions between components\n- May involve multiple modules\n- Ca"
  },
  {
    "title": "Cypress Guide",
    "path": "/tests/frameworks/cypress",
    "content": "\nCypress Guide\n\nCypress is a next-generation front-end testing tool built for the modern web. It enables fast, easy and reliable testing for anything that runs in a browser.\n\nKey Features\n\n- Real-time reloads\n- Automatic waiting\n- Time travel debugging\n- Network traffic control\n- Screenshots and videos\n- Cross-browser testing\n- Interactive test runner\n- Flake detection\n\nGetting Started\n\n::: code-with-tooltips\n\n\n\n:::\n\nBasic Test Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Commands\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Features\n\nCustom Commands\n\n::: code-with-tooltips\n\n\n\n:::\n\nFixtures\n\n::: code-with-tooltips\n\n\n\n:::\n\nNetwork Interception\n\n::: code-with-tooltips\n\n\n\n:::\n\nTesting Patterns\n\nPage Objects\n\n::: code-with-tooltips\n\n\n\n:::\n\nAPI Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nConfiguration\n\ncypress.config.js\n\n::: code-with-tooltips\n\n\n\n:::\n\nEnvironment Variables\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Selectors\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Waiting\n\n::: code-with-tool"
  },
  {
    "title": "Jest Guide",
    "path": "/tests/frameworks/jest",
    "content": "\nJest Guide\n\nJest is a delightful JavaScript testing framework with a focus on simplicity and support for large web applications. It works with projects using Babel, TypeScript, Node, React, Angular, Vue, and more.\n\nKey Features\n\n- Zero config for most JavaScript projects\n- Snapshots for UI testing\n- Built-in code coverage reporting\n- Interactive mode for development\n- Isolated test execution\n- Powerful mocking capabilities\n- Rich matcher API\n\nGetting Started\n\n::: code-with-tooltips\n\n\n\n:::\n\nBasic Test Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Matchers\n\n::: code-with-tooltips\n\n\n\n:::\n\nConfiguration\n\nJest Configuration File\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Features\n\nMock Functions\n\n::: code-with-tooltips\n\n\n\n:::\n\nAsync Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nSnapshot Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nTesting React Components\n\nComponent Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nContext Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nCustom Hooks Testing\n\n::: code-with-tooltips\n\n\n"
  },
  {
    "title": "Nightwatch Guide",
    "path": "/tests/frameworks/nightwatch",
    "content": "\nNightwatch Guide\n\nNightwatch.js is an integrated framework for automated testing of web applications and websites using Node.js. It provides a complete end-to-end testing solution.\n\nKey Features\n\n- End-to-end testing framework\n- Built-in test runner\n- Selenium WebDriver integration\n- Page Object Model support\n- CSS/Xpath selectors\n- Cloud testing integration\n- Parallel test execution\n- Visual regression testing\n\nGetting Started\n\n::: code-with-tooltips\n\n\n\n:::\n\nCore Concepts\n\nConfiguration\n\n::: code-with-tooltips\n\n\n\n:::\n\nBasic Test Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\nElement Commands\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Features\n\nPage Objects\n\n::: code-with-tooltips\n\n\n\n:::\n\nCustom Commands\n\n::: code-with-tooltips\n\n\n\n:::\n\nAssertions\n\n::: code-with-tooltips\n\n\n\n:::\n\nTesting Patterns\n\nVisual Regression\n\n::: code-with-tooltips\n\n\n\n:::\n\nAPI Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nMobile Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Element Selection\n\n::: code-with-toolti"
  },
  {
    "title": "Playwright Guide",
    "path": "/tests/frameworks/playwright",
    "content": "\nPlaywright Guide\n\nPlaywright is a powerful testing framework by Microsoft that enables reliable end-to-end testing for modern web apps. It supports multiple browser engines including Chromium, Firefox, and WebKit.\n\nKey Features\n\n- Cross-browser support\n- Auto-wait capabilities\n- Network interception\n- Mobile device emulation\n- Test parallelization\n- Visual comparisons\n- API testing support\n- Codegen tool\n\nGetting Started\n\n::: code-with-tooltips\n\n\n\n:::\n\nBasic Test Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Actions\n\n::: code-with-tooltips\n\n\n\n:::\n\nTest Configuration\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Features\n\nAPI Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nNetwork Interception\n\n::: code-with-tooltips\n\n\n\n:::\n\nVisual Comparison\n\n::: code-with-tooltips\n\n\n\n:::\n\nTesting Patterns\n\nPage Objects\n\n::: code-with-tooltips\n\n\n\n:::\n\nComponent Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nMobile Testing\n\nDevice Emulation\n\n::: code-with-tooltips\n\n\n\n:::\n\nTouch Interactions\n\n::: code-with-tooltips\n\n\n\n:"
  },
  {
    "title": "Puppeteer Guide",
    "path": "/tests/frameworks/puppeteer",
    "content": "\nPuppeteer Guide\n\nPuppeteer is a Node.js library that provides a high-level API to control Chrome/Chromium over the DevTools Protocol. It's particularly useful for automated testing, web scraping, and generating screenshots/PDFs.\n\nKey Features\n\n- Chrome DevTools Protocol support\n- Headless browser automation\n- Network interception\n- Performance monitoring\n- PDF generation\n- Screenshot capture\n- Keyboard/mouse simulation\n- Mobile device emulation\n\nGetting Started\n\n::: code-with-tooltips\n\n\n\n:::\n\nBasic Test Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Operations\n\n::: code-with-tooltips\n\n\n\n:::\n\nCore Concepts\n\nBrowser Setup\n\n::: code-with-tooltips\n\n\n\n:::\n\nNavigation\n\n::: code-with-tooltips\n\n\n\n:::\n\nElement Selection\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Features\n\nPage Interactions\n\n::: code-with-tooltips\n\n\n\n:::\n\nNetwork Monitoring\n\n::: code-with-tooltips\n\n\n\n:::\n\nJavaScript Execution\n\n::: code-with-tooltips\n\n\n\n:::\n\nTesting Patterns\n\nScreenshot Capture\n\n::: code-with-tooltips\n\n\n\n:::\n\nPe"
  },
  {
    "title": "Selenium Guide",
    "path": "/tests/frameworks/selenium",
    "content": "\nSelenium Guide\n\nSelenium WebDriver is a widely-used tool for browser automation that enables you to control browser behavior programmatically and run automated tests across different browsers.\n\nKey Features\n\n- Multi-browser support\n- Multiple programming language bindings\n- Extensive browser manipulation capabilities\n- Support for complex user interactions\n- Headless browser testing\n- Screenshot capture\n- Page object model support\n- Wait strategies\n\nGetting Started\n\n::: code-with-tooltips\n\n\n\n:::\n\nBasic Test Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Operations\n\n::: code-with-tooltips\n\n\n\n:::\n\nPage Object Model Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nCore Concepts\n\nWebDriver Setup\n\n::: code-with-tooltips\n\n\n\n:::\n\nElement Location\n\n::: code-with-tooltips\n\n\n\n:::\n\nInteractions\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Features\n\nWait Strategies\n\n::: code-with-tooltips\n\n\n\n:::\n\nJavaScript Execution\n\n::: code-with-tooltips\n\n\n\n:::\n\nWindow Management\n\n::: code-with-tooltips\n\n\n\n:::\n\nTesting P"
  },
  {
    "title": "TestCafe Guide",
    "path": "/tests/frameworks/testcafe",
    "content": "\nTestCafe Guide\n\nTestCafe is a Node.js tool to automate end-to-end web testing. It's easy to set up, works on all popular environments, and provides powerful features for testing modern web apps.\n\nKey Features\n\n- No WebDriver or other testing software required\n- Cross-browser support\n- Concurrent test execution\n- Built-in waiting mechanism\n- Page object model support\n- Mobile device testing\n- Smart assertion query mechanism\n- Stable tests\n\nGetting Started\n\n::: code-with-tooltips\n\n\n\n:::\n\nCore Concepts\n\nTest Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\nSelectors\n\n::: code-with-tooltips\n\n\n\n:::\n\nActions\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Features\n\nPage Model Pattern\n\n::: code-with-tooltips\n\n\n\n:::\n\nRequest Hooks\n\n::: code-with-tooltips\n\n\n\n:::\n\nClient Scripts\n\n::: code-with-tooltips\n\n\n\n:::\n\nTesting Patterns\n\nVisual Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nMobile Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nAPI Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Selector Best Practices\n\n:"
  },
  {
    "title": "Testing Library Guide",
    "path": "/tests/frameworks/testing-library",
    "content": "\nTesting Library Guide\n\nTesting Library is a family of packages that help you test UI components in a way that resembles how users interact with your app. It encourages better testing practices by focusing on testing behavior rather than implementation details.\n\nKey Features\n\n- User-centric testing approach\n- Framework agnostic (works with React, Vue, Angular, etc.)\n- Built-in accessibility checks\n- Powerful querying capabilities\n- Async utilities\n- Event simulation\n- Semantic queries\n\nGetting Started\n\n::: code-with-tooltips\n\n\n\n:::\n\nBasic Test Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Queries\n\n::: code-with-tooltips\n\n\n\n:::\n\nUser Events\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Queries\n\nPriority Order\n\n::: code-with-tooltips\n\n\n\n:::\n\nQuery Variants\n\n::: code-with-tooltips\n\n\n\n:::\n\nTesting Patterns\n\nForm Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nAsync Operations\n\n::: code-with-tooltips\n\n\n\n:::\n\nEvent Handling\n\n::: code-with-tooltips\n\n\n\n:::\n\nFramework Integration\n\nReact Testing\n\n::: code"
  },
  {
    "title": "Vitest Guide",
    "path": "/tests/frameworks/vitest",
    "content": "\nVitest Guide\n\nVitest is a next-generation testing framework designed for Vite-based applications. It provides a modern, fast, and feature-rich testing experience.\n\nKey Features\n\n- Native ESM support\n- TypeScript support out of the box\n- Watch mode with smart file detection\n- Jest-compatible API\n- Snapshot testing\n- Code coverage\n- Multi-threading\n\nGetting Started\n\n::: code-with-tooltips\n\n\n\n:::\n\nBasic Test Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\nConfiguration\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Features\n\nMocking\n\n::: code-with-tooltips\n\n\n\n:::\n\nSnapshot Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nTest Coverage\n\n::: code-with-tooltips\n\n\n\n:::\n\nCustom Matchers\n\n::: code-with-tooltips\n\n\n\n:::\n\nIntegration with Other Tools\n\nTypeScript\n\n::: code-with-tooltips\n\n\n\n:::\n\nReact Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nVue Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Test Organization\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Setup and Teardown\n\n::: code-with-tooltips\n\n\n\n:::\n\n3. Async Testi"
  },
  {
    "title": "WebdriverIO Guide",
    "path": "/tests/frameworks/webdriverio",
    "content": "\nWebdriverIO Guide\n\nWebdriverIO is a test automation framework that allows you to run tests with over 150 browser and mobile platforms. It's designed to be extendable, flexible, and feature-rich.\n\nKey Features\n\n- Modern syntax and APIs\n- Smart selectors\n- Automatic wait strategies\n- Mobile testing support\n- Parallel test execution\n- Real-time reporting\n- Custom commands\n- Service integration\n\nGetting Started\n\n::: code-with-tooltips\n\n\n\n:::\n\nBasic Test Structure\n\n::: code-with-tooltips\n\n\n\n:::\n\nCommon Commands\n\n::: code-with-tooltips\n\n\n\n:::\n\nPage Objects\n\n::: code-with-tooltips\n\n\n\n:::\n\nConfiguration Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nCore Concepts\n\nConfiguration\n\n::: code-with-tooltips\n\n\n\n:::\n\nElement Interactions\n\n::: code-with-tooltips\n\n\n\n:::\n\nSelectors\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Features\n\nPage Objects\n\n::: code-with-tooltips\n\n\n\n:::\n\nCustom Commands\n\n::: code-with-tooltips\n\n\n\n:::\n\nService Integration\n\n::: code-with-tooltips\n\n\n\n:::\n\nTesting Patterns\n\nVisual Regression\n"
  },
  {
    "title": "Testing Overview",
    "path": "/tests/index",
    "content": "\nTesting Overview\n\nThis section covers various aspects of testing in modern web development, from testing strategies to specific frameworks and utilities.\n\nWhat You'll Find Here\n\n- **Testing Strategy**: Learn about different approaches to testing, including unit tests, integration tests, and end-to-end tests\n- **Testing Patterns**: Common patterns and best practices for writing effective tests\n- **Test Utilities**: Helpful utilities and tools for testing\n- **Framework Guides**: Detailed guides for popular testing frameworks\n\nGetting Started\n\nChoose a topic from the sidebar to begin exploring testing concepts and practices. We recommend starting with the Deep Dive into Testing Strategy for a comprehensive understanding of testing fundamentals.\n"
  },
  {
    "title": "TypeScript Test Utilities Guide",
    "path": "/tests/test-utilities",
    "content": "\nTest Utilities in TypeScript\n\nThis section provides a collection of type-safe test utilities and patterns for writing better tests in TypeScript.\n\nOverview\n\nTest utilities help you write more maintainable and type-safe tests while reducing boilerplate code.\n\nBasic Test Utilities\n\nType-Safe Test Factory\n\n::: code-with-tooltips\n\n\n\n:::\n\nMock Data Generator\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Utilities\n\nTest Context Manager\n\n::: code-with-tooltips\n\n\n\n:::\n\nMock Service Generator\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Test Utilities:\n\n   - Keep utilities type-safe\n   - Make utilities reusable\n   - Document utility behavior\n\n2. Test Data:\n\n   - Use factories for test data\n   - Generate unique values\n   - Clean up test data\n\n3. Test Context:\n   - Manage test lifecycle\n   - Share common setup\n   - Handle cleanup properly\n\nReferences\n\n- Jest Documentation\n- TypeScript Testing Documentation\n- Vitest Documentation\n"
  },
  {
    "title": "TypeScript Testing Patterns Guide",
    "path": "/tests/testing-patterns",
    "content": "\nTesting Patterns in TypeScript\n\nThis section explores patterns and best practices for testing TypeScript code, including type testing and test utilities.\n\nOverview\n\nTypeScript testing combines runtime behavior testing with compile-time type checking to ensure both functional correctness and type safety.\n\nBasic Testing Patterns\n\nUnit Testing with Jest\n\n::: code-with-tooltips\n\n\n\n:::\n\nAsync Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Testing Patterns\n\nType Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nMock Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Test Organization:\n\n   - Group related tests\n   - Use descriptive names\n   - Follow AAA pattern (Arrange, Act, Assert)\n\n2. Type Testing:\n\n   - Test type constraints\n   - Verify type inference\n   - Test edge cases\n\n3. Mock Testing:\n   - Create type-safe mocks\n   - Test error conditions\n   - Verify state changes\n\nReferences\n\n- Jest Documentation\n- TypeScript Testing Documentation\n"
  },
  {
    "title": "clear-timers",
    "path": "/timers/clear-timers",
    "content": "Custom clearAllTimers Implementation\n\nOverview\n\nA comprehensive timer management system that can track and clear all types of timers (setTimeout, setInterval) in an application. This implementation helps prevent memory leaks and provides a clean way to reset timer state.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Concepts\n\n1. **Singleton Pattern**: Single instance for global timer management\n2. **Timer Tracking**: Keep track of all active timers\n3. **Group Management**: Organize timers by groups\n4. **Resource Cleanup**: Proper cleanup of all timer resources\n5. **Type Safety**: TypeScript support for better reliability\n\nEdge Cases\n\n- Multiple timer manager instances\n- Clearing already cleared timers\n- Maximum number of concurrent timers\n- Browser tab visibility changes\n- System sleep/wake cycles\n\nCommon Pitfalls\n\n1. **Memory Leaks**: Not clearing all timer references\n2. **Zombie Timers**: Timers that should be dead but aren't\n3. **R"
  },
  {
    "title": "setinterval",
    "path": "/timers/setinterval",
    "content": "Custom setInterval Implementation\n\nOverview\n\nA custom implementation of setInterval that provides enhanced features like\npause/resume, dynamic interval adjustment, and proper cleanup. This\nimplementation also includes drift correction and precise timing options.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Concepts\n\n1. **Drift Correction**: Compensate for execution time drift\n2. **Precise Timing**: Option for more accurate intervals\n3. **Dynamic Adjustment**: Change interval duration on the fly\n4. **State Management**: Pause/resume functionality\n5. **Resource Cleanup**: Proper interval cleanup\n\nEdge Cases\n\n- Very short intervals (<16ms)\n- Very long intervals (>MAX_INT)\n- Browser throttling\n- System sleep/wake\n- Heavy CPU load\n\nCommon Pitfalls\n\n1. **Timer Drift**: Accumulated timing errors\n2. **Memory Leaks**: Uncleaned intervals\n3. **CPU Usage**: Too frequent intervals\n4. **Browser Limitations**: Minimum interval times\n\nBest Practice"
  },
  {
    "title": "settimeout",
    "path": "/timers/settimeout",
    "content": "Custom setTimeout Implementation\n\nOverview\n\nA custom implementation of setTimeout that uses promises and provides additional\nfeatures like cancellation, pause/resume, and better type safety. This\nimplementation also provides a way to track and manage multiple timeouts.\n\nImplementation\n\n::: code-with-tooltips\n\n\n\n:::\n\nUsage Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nKey Concepts\n\n1. **Timer Management**: Track all active timeouts\n2. **Pause/Resume**: Ability to pause and resume timeouts\n3. **Promise Integration**: Promise-based API\n4. **Cleanup**: Proper resource management\n5. **Type Safety**: TypeScript support\n\nEdge Cases\n\n- Multiple pause/resume calls\n- Clearing already completed timeout\n- Negative delay values\n- Maximum timeout value\n- Browser tab inactive\n\nCommon Pitfalls\n\n1. **Memory Leaks**: Not clearing unused timeouts\n2. **Timer Accuracy**: JavaScript timing limitations\n3. **Resource Management**: Too many concurrent timeouts\n4. **State Management**: Complex pause/resume states\n\nBe"
  },
  {
    "title": "TypeScript Array Operations Guide",
    "path": "/typescript/array-operations",
    "content": "\nArray Operations in TypeScript\n\nThis section covers type-safe array operations and utility functions for array manipulation.\n\nOverview\n\nTypeScript provides powerful type checking for array operations. This guide covers common patterns and utilities for working with arrays in a type-safe manner.\n\nType-Safe Array Methods\n\nFilter with Type Predicates\n\n::: code-with-tooltips\n\n\n\n:::\n\nMap with Type Inference\n\n::: code-with-tooltips\n\n\n\n:::\n\nReduce with Accumulator Types\n\n::: code-with-tooltips\n\n\n\n:::\n\nArray Utility Functions\n\nSafe Array Access\n\n::: code-with-tooltips\n\n\n\n:::\n\nChunk Array\n\n::: code-with-tooltips\n\n\n\n:::\n\nUnique Values\n\n::: code-with-tooltips\n\n\n\n:::\n\nType-Safe Array Transformations\n\nTuple Types\n\n::: code-with-tooltips\n\n\n\n:::\n\nArray Element Types\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Type Guards with Arrays:\n\n   \n\n2. Immutable Array Operations:\n\n   \n\n3. Type-Safe Array Sorting:\n\n   \n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nReferences\n\n- TypeScript Handbook"
  },
  {
    "title": "TypeScript Array Utilities Guide",
    "path": "/typescript/array-utilities",
    "content": "\nArray Utilities in TypeScript\n\nThis section provides a collection of type-safe array utility functions and patterns for common array operations.\n\nOverview\n\nArray utilities help you perform common array operations in a type-safe manner while maintaining code readability and reusability.\n\nBasic Utilities\n\nArray Creation\n\n::: code-with-tooltips\n\n\n\n:::\n\nArray Manipulation\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Utilities\n\nArray Type Checking\n\n::: code-with-tooltips\n\n\n\n:::\n\nArray Transformations\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Type Safety:\n\n   - Use generic type parameters\n   - Implement proper type guards\n   - Validate array contents\n\n2. Performance:\n\n   - Minimize array copies\n   - Use appropriate data structures\n   - Consider lazy evaluation\n\n3. Reusability:\n   - Create composable utilities\n   - Document edge cases\n   - Handle error conditions\n\nReferences\n\n- TypeScript Handbook - Generics\n- TypeScript Deep Dive - Arr"
  },
  {
    "title": "TypeScript Conditional Types Guide",
    "path": "/typescript/conditional-types",
    "content": "\nConditional Types in TypeScript\n\nThis section explores TypeScript's conditional types and their applications in creating flexible type definitions.\n\nOverview\n\nConditional types help you create type definitions that depend on other types, similar to if statements but at the type level.\n\nBasic Conditional Types\n\nType Conditions\n\n::: code-with-tooltips\n\n\n\n:::\n\nType Distribution\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nType Inference in Conditional Types\n\n::: code-with-tooltips\n\n\n\n:::\n\nRecursive Conditional Types\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Type Design:\n\n   - Keep conditions simple and focused\n   - Use type inference when possible\n   - Document complex conditional types\n\n2. Error Handling:\n\n   - Use union types for error cases\n   - Provide meaningful error types\n   - Handle all possible conditions\n\n3. Performance:\n   - Avoid deeply nested conditions\n   - Cache complex type computations\n   - Use type aliase"
  },
  {
    "title": "TypeScript Immutable State Guide",
    "path": "/typescript/immutable-state",
    "content": "\nImmutable State in TypeScript\n\nThis section explores patterns and best practices for implementing immutable state in TypeScript applications.\n\nOverview\n\nImmutable state is a fundamental concept in modern application development that helps prevent bugs and makes state changes more predictable and traceable.\n\nCore Concepts\n\n1. Readonly Types\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Immutable Collections\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\n1. Immutable State Updates\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Immutable Records\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Immutability Patterns:\n\n   - Use TypeScript's readonly modifiers\n   - Implement deep immutability\n   - Return new instances on updates\n\n2. Performance Considerations:\n\n   - Use structural sharing\n   - Implement memoization\n   - Consider using Immutable.js for large datasets\n\n3. Type Safety:\n   - Leverage TypeScript's type system\n   - Use const assertions\n   - Imple"
  },
  {
    "title": "TypeScript Mapped Types Guide",
    "path": "/typescript/mapped-types",
    "content": "\nMapped Types in TypeScript\n\nThis section explores TypeScript's mapped types and their applications in type transformations.\n\nOverview\n\nMapped types allow you to create new types based on existing ones by transforming their properties in a consistent way.\n\nBasic Mapped Types\n\nProperty Modifiers\n\n::: code-with-tooltips\n\n\n\n:::\n\nGeneric Mapped Types\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nProperty Remapping\n\n::: code-with-tooltips\n\n\n\n:::\n\nConditional Type Mapping\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Type Mapping:\n\n   - Use built-in mapped types when possible\n   - Create reusable generic mapped types\n   - Document complex type transformations\n\n2. Property Remapping:\n\n   - Use template literal types for naming\n   - Consider type inference implications\n   - Handle edge cases explicitly\n\n3. Performance:\n   - Avoid deeply nested mapped types\n   - Cache complex type computations\n   - Use type aliases for readability\n\nRe"
  },
  {
    "title": "TypeScript Observable State Guide",
    "path": "/typescript/observable-state",
    "content": "\nObservable State in TypeScript\n\nThis section explores patterns and best practices for implementing observable state in TypeScript applications.\n\nOverview\n\nObservable state patterns allow for reactive state management where components can subscribe to state changes and react accordingly.\n\nCore Concepts\n\n1. Basic Observable\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Event Emitter\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\n1. Observable Store\n\n::: code-with-tooltips\n\n\n\n:::\n\n2. Computed Observables\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. State Management:\n\n   - Keep state immutable\n   - Use selectors for derived state\n   - Implement proper cleanup\n\n2. Performance:\n\n   - Use memoization for computed values\n   - Implement shallow equality checks\n   - Clean up subscriptions\n\n3. Type Safety:\n   - Define strict interfaces\n   - Use discriminated unions\n   - Leverage generic constraints\n\nReferences\n\n- TypeScript Handbook - Generics\n- "
  },
  {
    "title": "TypeScript State Management Guide",
    "path": "/typescript/state-management",
    "content": "\nTypeScript State Management\n\nThis section covers TypeScript-specific state management patterns and best practices.\n\nOverview\n\nState management in TypeScript applications requires careful consideration of type safety, immutability, and reactivity. This guide explores various patterns and implementations.\n\nBasic State Management\n\nSimple State Container\n\n::: code-with-tooltips\n\n\n\n:::\n\nType-Safe Actions\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nImmutable State Updates\n\n::: code-with-tooltips\n\n\n\n:::\n\nObservable State\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Type Safety:\n\n   - Use strict TypeScript configurations\n   - Leverage type inference\n   - Define explicit action types\n\n2. Immutability:\n\n   - Use readonly modifiers\n   - Implement deep immutability\n   - Return new state objects\n\n3. Performance:\n   - Implement memoization\n   - Use shallow equality checks\n   - Batch state updates\n\nReferences\n\n- TypeScript Handbook - Ge"
  },
  {
    "title": "TypeScript String Manipulation Guide",
    "path": "/typescript/string-manipulation",
    "content": "\nString Manipulation in TypeScript\n\nThis section covers type-safe string operations and template literal types.\n\nOverview\n\nTypeScript provides powerful features for string manipulation, including template literal types and type-safe string operations.\n\nTemplate Literal Types\n\nBasic Template Literals\n\n::: code-with-tooltips\n\n\n\n:::\n\nCombining Template Literals\n\n::: code-with-tooltips\n\n\n\n:::\n\nExtracting String Parts\n\n::: code-with-tooltips\n\n\n\n:::\n\nType-Safe String Operations\n\nString Validation\n\n::: code-with-tooltips\n\n\n\n:::\n\nString Transformations\n\n::: code-with-tooltips\n\n\n\n:::\n\nString Utility Functions\n\nSafe Substring\n\n::: code-with-tooltips\n\n\n\n:::\n\nString Format\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Type-Safe String Literals:\n\n   \n\n2. String Enum Alternatives:\n\n   \n\n3. String Pattern Matching:\n\n   \n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nReferences\n\n- TypeScript Handbook - Template Literal Types\n- TypeScript Deep Dive - String Literal Types\n"
  },
  {
    "title": "TypeScript String Utilities Guide",
    "path": "/typescript/string-utilities",
    "content": "\nString Utilities in TypeScript\n\nThis section provides a collection of type-safe string utility functions and patterns for common string operations.\n\nOverview\n\nString utilities help you manipulate and validate strings in a type-safe manner while maintaining code readability and reusability.\n\nBasic Utilities\n\nString Validation\n\n::: code-with-tooltips\n\n\n\n:::\n\nString Transformation\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Utilities\n\nString Templates\n\n::: code-with-tooltips\n\n\n\n:::\n\nString Manipulation\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. String Manipulation:\n\n   - Use template literals when possible\n   - Handle edge cases explicitly\n   - Consider Unicode support\n\n2. Performance:\n\n   - Cache regular expressions\n   - Minimize string concatenations\n   - Use appropriate string methods\n\n3. Validation:\n   - Use strict validation rules\n   - Provide meaningful error messages\n   - Handle special characters\n\nReferences\n\n- TypeScript Ha"
  },
  {
    "title": "TypeScript Template Literals Guide",
    "path": "/typescript/template-literals",
    "content": "\nTemplate Literals in TypeScript\n\nThis section explores TypeScript's template literal types and their applications in type-safe string manipulation.\n\nOverview\n\nTemplate literal types combine literal types and string manipulation to create powerful type-safe string patterns.\n\nBasic Template Literals\n\nString Literals\n\n::: code-with-tooltips\n\n\n\n:::\n\nUnion Types in Template Literals\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nIntrinsic String Manipulation Types\n\n::: code-with-tooltips\n\n\n\n:::\n\nPattern Matching with Template Literals\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Type Design:\n\n   - Keep template literals simple\n   - Use union types effectively\n   - Consider type inference\n\n2. Pattern Matching:\n\n   - Use specific patterns\n   - Handle edge cases\n   - Validate inputs\n\n3. Performance:\n   - Avoid complex unions\n   - Cache type computations\n   - Use type aliases\n\nReferences\n\n- TypeScript Handbook - Template Literal Type"
  },
  {
    "title": "TypeScript Type Guards Guide",
    "path": "/typescript/type-guards",
    "content": "\nType Guards in TypeScript\n\nThis section covers TypeScript type guards and their practical applications in type narrowing.\n\nOverview\n\nType guards are expressions that perform runtime checks to guarantee the type of a value in a given scope. They help TypeScript narrow down the type of a variable within conditional blocks.\n\nBasic Type Guards\n\ntypeof Type Guard\n\n::: code-with-tooltips\n\n\n\n:::\n\ninstanceof Type Guard\n\n::: code-with-tooltips\n\n\n\n:::\n\nCustom Type Guards\n\nUser-Defined Type Guards\n\n::: code-with-tooltips\n\n\n\n:::\n\nArray Type Guards\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nDiscriminated Unions\n\n::: code-with-tooltips\n\n\n\n:::\n\nAssertion Functions\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Type Guard Design:\n\n   - Keep type guards simple and focused\n   - Use descriptive names that indicate the check\n   - Return boolean for type predicates\n\n2. Error Handling:\n\n   - Use assertion functions for invariants\n   - Provide d"
  },
  {
    "title": "TypeScript Type Inference Guide",
    "path": "/typescript/type-inference",
    "content": "\nType Inference in TypeScript\n\nThis section explores TypeScript's type inference capabilities and best practices for leveraging them effectively.\n\nOverview\n\nType inference is TypeScript's ability to automatically determine types based on context. Understanding how inference works helps write more concise and maintainable code.\n\nBasic Type Inference\n\nVariable Initialization\n\n::: code-with-tooltips\n\n\n\n:::\n\nFunction Return Types\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Inference\n\nGeneric Type Inference\n\n::: code-with-tooltips\n\n\n\n:::\n\nArray Method Inference\n\n::: code-with-tooltips\n\n\n\n:::\n\nContextual Typing\n\nEvent Handlers\n\n::: code-with-tooltips\n\n\n\n:::\n\nPromise Callbacks\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Type Inference Usage:\n\n   - Let TypeScript infer simple types\n   - Explicitly type complex structures\n   - Use type annotations for clarity\n\n2. Generic Type Inference:\n\n   - Leverage generic type parameters\n   - Use constr"
  },
  {
    "title": "TypeScript Type-Safe Arrays Guide",
    "path": "/typescript/type-safe-arrays",
    "content": "\nType-Safe Arrays in TypeScript\n\nThis section explores patterns and best practices for working with arrays in a type-safe manner using TypeScript.\n\nOverview\n\nType-safe arrays ensure that array operations maintain type safety and prevent runtime errors through static type checking.\n\nBasic Array Types\n\nArray Type Declarations\n\n::: code-with-tooltips\n\n\n\n:::\n\nArray Type Inference\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Patterns\n\nType-Safe Array Operations\n\n::: code-with-tooltips\n\n\n\n:::\n\nArray Type Guards\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Array Type Safety:\n\n   - Use explicit type annotations\n   - Leverage readonly arrays\n   - Implement proper type guards\n\n2. Array Operations:\n\n   - Use type-safe array methods\n   - Handle empty array cases\n   - Validate array contents\n\n3. Performance:\n   - Avoid unnecessary array copies\n   - Use appropriate array methods\n   - Consider using Set for lookups\n\nReferences\n\n- TypeScript Handboo"
  },
  {
    "title": "TypeScript Type Testing Guide",
    "path": "/typescript/type-testing",
    "content": "\nType Testing in TypeScript\n\nThis section explores techniques and patterns for testing TypeScript types to ensure type-level correctness.\n\nOverview\n\nType testing verifies that your type definitions work as expected and catch type errors at compile time.\n\nBasic Type Testing\n\nType Assertions\n\n::: code-with-tooltips\n\n\n\n:::\n\nType Equality Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nAdvanced Type Testing\n\nGeneric Type Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nConditional Type Testing\n\n::: code-with-tooltips\n\n\n\n:::\n\nReal-World Example\n\n::: code-with-tooltips\n\n\n\n:::\n\nBest Practices\n\n1. Type Testing Strategy:\n\n   - Test type constraints\n   - Verify type inference\n   - Test edge cases\n\n2. Type Assertions:\n\n   - Use explicit type assertions\n   - Test both positive and negative cases\n   - Verify type relationships\n\n3. Test Organization:\n   - Group related type tests\n   - Use descriptive names\n   - Document complex type tests\n\nReferences\n\n- TypeScript Handbook - Type Testing\n- tsd - Type Testing Tool\n"
  },
  {
    "title": "TypeScript Utility Types Guide",
    "path": "/typescript/utility-types",
    "content": "\nTypeScript Utility Types\n\nThis section covers essential TypeScript utility types and their practical applications.\n\nOverview\n\nTypeScript provides several utility types to help with common type transformations. Here are some of the most frequently used ones:\n\n- `Partial<T>`\n- `Required<T>`\n- `Pick<T, K>`\n- `Omit<T, K>`\n- `Record<K, T>`\n- `Exclude<T, U>`\n- `Extract<T, U>`\n- `NonNullable<T>`\n- `ReturnType<T>`\n- `Parameters<T>`\n\nExamples\n\nEach utility type serves a specific purpose in type manipulation and safety. Let's explore them with practical examples.\n\nBuilt-in Utility Types\n\nPartial\\<T\\>\n\nMakes all properties in T optional:\n\n::: code-with-tooltips\n\n\n\n:::\n\nRequired\\<T>\n\nMakes all properties in T required:\n\n::: code-with-tooltips\n\n\n\n:::\n\nPick\\<T, K>\n\nCreates a type by picking the specified properties K from T:\n\n::: code-with-tooltips\n\n\n\n:::\n\nCustom Utility Types\n\nDeepPartial\\<T>\n\nMakes all properties in T optional recursively:\n\n::: code-with-tooltips\n\n\n\n:::\n\nNonNullable\\<T>\n\nRemoves "
  }
]